\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xspace}
\usepackage{enumitem}
\usepackage{authblk}
\usepackage{hyperref}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{comstyle}{
  morecomment=[l][\color{mygreen}]{####}
}

\lstset{ %
  language=C++, frame=single, keywordstyle=\color{blue}, stringstyle=\color{mymauve}, commentstyle=\color{mygreen},
  basicstyle=\footnotesize\ttfamily, showlines=true, aboveskip=\bigskipamount, belowskip=\bigskipamount, frame=trBL %
}


\newcommand{\bc}{BaPCod\xspace}
\newcommand{\f}{}
\renewcommand{\lstlistingname}{Code}
\newcommand{\bap}{Branch and Price\xspace}

\title{BaPCod --- a generic branch-and-price code}

\author[1,2]{Ruslan Sadykov\thanks{Corresponding author: \texttt{ruslan.sadykov@inria.fr}}}
\author[3]{Fran\c{c}ois Vanderbeck}

\affil[1]{Bordeaux-Sud-Ouest Inria Research Centre, 200 avenue de la Vieille Tour, 33405 Talence, France}
\affil[2]{Institut de Math\'{e}matiques de Bordeaux, Universit\'{e} de Bordeaux, 351 cours de la Lib\'{e}ration, 33405
  Talence, France}
\affil[3]{Atoptima SAS, 16 place Sainte Eulalie, 33000 Bordeaux, France}

\date{March 20, 2023}

\begin{document}
\maketitle

\begin{abstract}
  This document presents a user guide for \bc version 0.77\footnote{The most recent version of this user guide is
    available on the \bc website: \texttt{https://bapcod.math.u-bordeaux.fr}}, a C++ library implementing a generic
  branch-cut-and-price solver. We give guidelines for installing \bc, using its modelling language, \bc
  parameterization, retrieving \bc statistics, and understanding \bc output. We also present the VRPSolver extension of
  \bc which allows one to model and efficiently solve a large number of vehicle routing and related problems.

  \bc was developed in Bordeaux University and Bordeaux Research Center of Inria, France.
\end{abstract}

\break

\tableofcontents

\break

\section{Introduction}
\label{sec:inroduction}

\bc is a prototype academic code that solves Mixed Integer Programs (MIP) by application of a Dantzig-Wolfe
reformulation technique. The reformulated problem is solved using the branch-cut-and-price algorithm which includes the
column generation procedure to solve the linear relaxation in each node of the branch-and-bound tree. The specificity of
this prototype is to offer a “black-box” implementation of the method:

\begin{enumerate}
\item the input is the set of constraints and variables of the MIP in its natural/ compact formulation;
\item the user specifies which of these constraints and variables define the subsystems on which the decomposition is
  based (it is handy to test different decompositions);
\item the reformulation is automatically generated by the code, without any input from the user to define master
  columns, their reduced cost, pricing problem, or Lagrangian bound;
\item a default column generation procedure is implemented that relies on an underlying LP/MIP solver to handle master and
  subproblem but the user can define a specific solver for the pricing problem;
\item a branching scheme that preserves the pricing problem structure is offered by default, it runs based on priorities
  and directives specified by the user on the original variables;
\item the user can specify custom cut generation callbacks and custom branching callbacks;
\item preprocessing, restricted master and diving primal heuristics, some stabilization techniques, and strong branching
  are available for use;
\item VRPSolver extension can be used, which includes a resource constrained shortest
  path problem (RCSP) solver, and some families of robust and non-robust cut separation and branching functors; these components can be used to devise state-of-the-art branch-cut-and-price algorithms for vehicle routing and related problems. VRPSolver extension is distributed in the compiled form. 
\end{enumerate}

Readers of this user guide are supposed to be familiar with the theory of Dantzig-Wolfe reformulations, the column
generation procedure, and the branch-cut-and-price method (see for example~\cite{DesrosierLubbecke:11a} for an
introduction).

The source code of \bc can be obtained on its web-page \url{https://bapcod.math.u-bordeaux.fr} after accepting the Inria licence for academic use. The following contacts can be used to communicate with the authors of the code:
\begin{description}
\item[laurent.facq@math.u-bordeaux.fr ---] issues with installation and running of demos;
\item[francois.clautiaux@math.u-bordeaux.fr ---] other issues.
\end{description}


\subsection{Code structure}
\label{sec:install}

We suppose that the code is
cloned or extracted to the \verb+BapcodFramework+ folder. The main folder structure is the following

\begin{Verbatim}
BapcodFramework
-- Applications
-- Bapcod
-- CMake
-- CMakeLists.txt
-- Documentation
-- Demos
-- License.pdf
-- README.md
-- Scripts
-- Tests
-- Tools
\end{Verbatim}

\verb+Applications+ folder should contain user applications, no applications are provided by default. We explain how to
create an application in Section~\ref{sec:newapp}. \verb+Bapcod+ folder contains the C++ source code of
\bc. \verb+Cmake+ folder and file \verb+CMakeLists.txt+ contain CMake scripts necessary for compiling and linking \bc,
its demos and user applications. \verb+Documentation+ folder contains the source of the present user guide. \verb+Demo+
folder contains demos which come together with \bc source code.  \verb+LICENCE.pdf+ and \verb+README.md+ files contain
the license and the installation instructions. The license stipulates that you can use \bc for free for academic
purposes. \verb+Scripts+ folder contains some scripts necessary for \bc installation and other tasks.
Some unit tests are available in \verb+Tests+ folder (for the moment, only for the VRPSolverEasy interface). \verb+Tools+
folder contains the compiled RCSP library, which is necessary for using the VRPSolver extension. RCSP library is pre-compiled for three major operating systems (Mac OS, Linux, and Windows). Third-party libraries are also installed to the \verb+Tools+ folder.

\subsection{Installation}
\label{sec:install}

The installation instructions are given in the \verb+README.md+ file. 

\subsection{Generation of the BaPCod shared library}
\label{sec:shared}

BaPCod shared library is needed for the Julia interface for VRPSolver (\url{https://github.com/inria-UFF/BaPCodVRPSolver.jl}) and for the VRPSolverEasy Python package (\url{https://github.com/inria-UFF/VRPSolverEasy}). Instructions how to generate the BaPCod shared library are also given in the \verb+README.md+ file.

\subsection{Creating a new application}
\label{sec:newapp}  

A demo or an application has the following structure by default 
\begin{Verbatim}
<ApplicationOrDemoName>
-- CMakeLists.txt
-- config
-- data
-- include
-- src
-- tests
\end{Verbatim}

File \verb+CMakeLists.txt+ contains CMake instructions necessary for compiling and linking the
application or demo. \verb+config+ folder contains configuration files. There are usually two configuration files: one
contains \bc parameters, and another contains application-specific parameters. \verb+data+ folder contains instance
files. \verb+include+ folder contains header files. \verb+src+ folder contains source files. \verb+tests+ folder
contains files and scripts to run non-regression tests. It is highly advised to create several  non-regression tests for
every user application. Non-regression tests usually verify that the solution value obtained after the run coincides
with the optimal value or the dual bound value.

A standard way to create a new application is by modification of a similar available demo. If there is no demo which is
similar to the intended application, please request the authors of the code to produce a similar demo. One advantage of
this method is to provide for the user a working tree that already contains the files needed by \verb+cmake+ for the
compilation and pre-filled configuration and test files. Another advantage is to provide for the user the code structure
that is easier to modify when making up the new application rather than starting from scratch.

First, copy the folder with the corresponding demo to the\\ \verb+BapcodFramework/Applications+ folder. Then modify the
folder name to the application name, and add the new folder name to file\\
\verb+BapcodFramework/Applications/CMakeLists.txt+ inside \verb+add_subdirectories()+ so that the makefile is produced
next time your run \verb+cmake+.

Afterwards, the code of the new application should be modified according to the problem one wants to solve. It is
advised to change the names of all classes in the application code or to change the name of the namespace used in the
code, in order to avoid a clash between different demos and applications. Usually, to adapt the code to the new
application, one should change the class with application-specific parameters, the data class, functions to read the
data, the model and the callbacks (pricing, cut generation, branching), if applicable.

After the code modification is complete, the makefile of the application should be generated. For that, run the
following commands from the \verb+BapcodFramework+ folder (on Mac OS and Linux)
\begin{Verbatim}
cd build
cmake ..
\end{Verbatim}
On Windows
\begin{Verbatim}
cmake -G "Visual Studio 16 2019" -A x64 -B "build"
\end{Verbatim}

These commands should also be run each time you add or delete header or source files for an application.

\subsection{Running a demo or application}
\label{sec:launchapp}  

To run the application or demo, execute the following commands on Linux or MacOS from the \verb+BapcodFramework+ folder
\begin{Verbatim}
cd build/Demos/<DemoName> # for a demo
cd build/Applications/<AppName> # for a application
make -j
bin/<DemoOrAppName> -b <BaPCod_config> -a <app_config> -i <instance> 
\end{Verbatim}

On Windows, run the following commands from the \verb+BapcodFramework+ folder
\begin{Verbatim}
cmake --build build --config Release --target <DemoOrAppName>
cd build/Demos/<DemoName> # for a demo
cd build/Applications/<AppName> # for an application
bin/Release/<DemoOrAppName>.exe -b <BaPCod_config> -a <app_config> -i <instance> 
\end{Verbatim}

Here \verb+<AppName>+ is the name of the application, \verb+<BaPCod_config>+ is the (relative) path to the
configuration file with BaPCod parameters, \verb+<app_config>+ is the (relative) path to the configuration file with
application-specific parameters (if such parameters exists), and \verb+<instance>+ is the (relative) path to the date
instance file. You can specify additional \bc and application-specific parameters in the command line using the format
\verb+ --<paramName> <value> +. If different values are given for the same parameter in the configuration file and in
the command line, the value given in the command line has more priority. See Section~\ref{sec:config} for an overview of
\bc parameters. In addition, in the command line one can specify \verb+-t <tree_file>+ parameter to change the
default (relative) path (which is \verb+BaPTree.dot+) to the file where the branch-and-bound tree information will be
stored in .DOT format for later visualisation.

It is highly advised to use a version control system (for example \verb+Git+) for user applications. It is standard to
create a different repository for every user application.

\subsection{Citing \bc}
\label{sec:citing}  

If you use \bc, please cite the present document:\\
Ruslan Sadykov and Francois Vanderbeck.  \newblock \bc --- a generic branch-and-price code.  \newblock {\em Technical
  report HAL-03340548}, Inria Bordeaux Sud-Ouest, 2021.


In addition, if you use the following components of \bc, we encourage
you to cite the corresponding papers listed below.
\begin{itemize}
\item If you use stabilization (automatic dual price smoothing stabilization is activated by default), please cite
  paper~\cite{PessoaSadykovUchoa:18b}:\\
  Artur Pessoa, Ruslan Sadykov, Eduardo Uchoa, and Francois Vanderbeck.  \newblock Automation and combination of
  linear-programming based stabilization techniques in column generation.  \newblock {\em INFORMS Journal on Computing},
  30(2):339--360, 2018.
\item If you use primal heuristics, please cite paper~\cite{SadykovVanderbecPessoa:19a}: \\
  Ruslan Sadykov, Francois Vanderbeck, Artur Pessoa, Issam Tahiri, and Eduardo Uchoa.  \newblock Primal heuristics for
  branch-and-price: the assets of diving methods.  \newblock {\em INFORMS Journal on Computing}, 31(2):251--267, 2019.
\item If you use the VPRSolver extension, please cite paper~\cite{PessoaSadykovUchoa:20a}: \\
  Artur Pessoa, Ruslan Sadykov, Eduardo Uchoa, and Francois Vanderbeck.  \newblock A generic exact solver for vehicle
  routing and related problems.  \newblock {\em Mathematical Programming}, 183:483--523, 2020.
\end{itemize}

\section{Modelling language}

This section overviews the modelling language, i.e. the C++ interface for \bc. To use this interface, one needs to
include the corresponding header file:
\begin{lstlisting}
#include "bcModelingLanguageC.hpp"
\end{lstlisting}

\bc models are similar to Mixed Integer Programs (MIPs): the user needs to define (continuous or integer) variables,
linear constraints and the objective function. Models are defined using of \emph{original} variables, i.e. variables of
the original compact formulation. There are however following differences.

The user needs to specify the decomposition: i.e. which constraints are dualized (remain in the master formulation) and
which constraints are imposed when solving the subproblem formulations (or pricing problems). Therefore, at least two
formulations should be defined: master one and at least one subproblem formulation. Each
subproblem formulations has integer bounds specifying how many solutions of this subproblem (i.e. how many columns
generated by this pricing problem) can participate in the global solution of the model. These bounds are useful to
define identical subproblems.

One can also use \bc to solve a MIP without applying decomposition; this may be useful when benchmarking a decomposition
against the original formulation. For this, one should define a single formulation and solve it (instead of solving the
model). 

Each variable belongs to a formulation. Subproblem constraints may involve only variables belonging to the corresponding
subproblem formulation. On the contrary, master constraints may involve variables belonging both to the master
formulation (we call them \emph{pure master} variables) and to the subproblem formulations. Coefficients of subproblem
variables in the master constraints determine the coefficients of columns in these constraints. 

The user has a possibility to define additional functors (C++ classes) to improve the performance of \bc. Functors are
enhanced versions of callbacks. A functor may have several functions which are called in different stages of the
solution process. The main functor is the pricing one which may be defined for a subproblem formulation for managing the
corresponding pricing problem. Another important functor is to separate robust cutting planes. Such cutting planes are
defined similarly to standard constraints using original variables. The user can also define a functor for generation of
robust branching constraints. Defining non-robust cutting plains and branching constraints is also possible but reserved
for an advanced use. The VRPSolver extension predefines a certain number of functors which are used for solving
vehicle routing and related problems. This extension is reviewed in Section~\ref{sec:vrpsolver}.


\subsection{Environment handler}
\label{sec:environment}

Every time \bc is used, one should first declare an environment handler of type \verb+BcInitialisation+ using constructor
\begin{lstlisting}
BcInitialisation(int argc, char *argv[], 
                 std::string config_filename = "config/bcParams.cfg");
\end{lstlisting}
Here \verb+argc+ and \verb+argv+ are the standard parameters of the \verb+main()+ function for command line arguments, and
\verb+config_filename+ is the default (relative) path to the configuration file with \bc parameters (for the case
\verb+-b+ parameter does not present in the command line).

Alternatively, one can declare an environment handler using constructor without parameters. 
\begin{lstlisting}
  BcInitialisation();
\end{lstlisting}
In this case case, all parameters are initialized with default values. 

The environment handler has several useful methods.
\begin{lstlisting}
UserControlParameters & param();
\end{lstlisting}
This method allows one to obtain the object with basic \bc parameters. One then can read and modify these
parameters. The available parameters are reviewed in Section~\ref{sec:config}.

\begin{lstlisting}
void bcReset();
\end{lstlisting}
This method should necessarily be called between two calls to \verb+BcModel::solve()+ function (of a model associated with this
environment handler) in order to reset internal counters.

Finally, for obtaining the statistics of the execution on can use the methods
\begin{lstlisting}
double getStatisticValue(const std::string & statName); 
long   getStatisticCounter(const std::string & statName); 
double getStatisticTime(const std::string & statName); 
\end{lstlisting}
to get values of individual statistics (records, counters, and timers). See
Section~\ref{sec:stats} for an overview of \bc statistics.


\subsection{Model handler}
\label{sec:model}

The model handler is used to define and solve \bc models. Every model should be associated with a \bc environment handler,
specified in the model constructor:
\begin{lstlisting}
BcModel(const BcInitialisation & bapcodInit,
	const std::string & modelName = "Model");
\end{lstlisting}

The main method of the handler solves the model:
\begin{lstlisting}
BcSolution BcModel::solve(); 
\end{lstlisting}
It returns the best found solution. The solution returned is disaggregated by default, see Section~\ref{sec:solution}
for details.

Solution management callback can be attached to a model:
\begin{lstlisting}
void attach(BcSolutionFoundCallback * solutionFoundCallbackPtr);
\end{lstlisting}
This callback is called every time a solution is found which is considered to be feasible by the model. This callback
can be used to check the feasibility of the solution (and thus the correctness of the model) and possibly show and/or
store it for future use.

\subsection{Formulation handlers}
\label{sec:formulation}

Formulation handler \verb+BcFormulation+ serves to manage formulations. The master formulation can be created or
obtained using the constructor
\begin{lstlisting}
BcMaster(BcModel & model, const std::string & name = "master");
\end{lstlisting}

Subproblem formulations are handled in an array of type \verb+BcColGenSpArray+. This array is created or obtained using
the constructor
\begin{lstlisting}
BcColGenSpArray(BcModel & model, const std::string & name = "colGenSp");
\end{lstlisting}

\verb+BcColGenSpArray+ has two operators \verb+operator()+ and \verb+operator[]+ to access individual formulations in
the array. These operators take integer indices as parameters. The first operator creates the formulation with given
indices if it does not exists. If no index is given, $0$ is used by default. The second operator does not create
formulation; if the formulation with given indices does not exist, an error occurs. For example, the following code
creates a model with the master formulation and two subproblem formulations.
\begin{lstlisting}
BcInitialisation bcInit(argc, argv);
BcModel model(bcInit);
BcMaster master(model);
BcColGenSpArray colGenSp(model);
colGenSp(0);
colGenSp(1);
\end{lstlisting}
The master formulation is created automatically if \verb+BcColGenSpArray+ is constructed. 

The master formulation of a subproblem one can be obtained with method
\begin{lstlisting}
const BcFormulation BcFormulation::master() const;
\end{lstlisting}
It returns \verb+BcMaster+ handler which inherits from \verb+BcFormulation+. If the formulation is not a subproblem one,
the returned master formulation is not defined. The same method, defined for \verb+BcModel+, allows one to retrieve the
master formulation of a model.

The list of subproblem formulations of a master one can be obtained with method
\begin{lstlisting}
const std::list< BcFormulation > & colGenSubProblemList() const;
\end{lstlisting}
If the formulation is not the master one, the returned list is empty.

For a subproblem formulation, one may define multiplicity bounds, i.e. the minimum and maximum number of solutions
(i.e. columns) from this formulation which can participate in the global model solution. These bounds will define
convexity constraints in the restricted master problem. The bounds are set with operators \verb+operator>=+,
\verb+operator<=+, and \verb+operator==+. For example, the code
\begin{lstlisting}
colGenSp[0] >= 1;
colGenSp[1] <= 2;
\end{lstlisting}
sets lower bound one for the subproblem formulation with index $0$ (by default, the lower bound is equal to $0$), and
upper bound two for the subproblem formulation with index $1$ (by default, the upper bound is equal to $\infty$).

For a subproblem formulation, one may also define the fixed cost, i.e. the value which will be added to the coefficient
in the objective function of every column coming from this subproblem. The method is 
\begin{lstlisting}
void BcFormulation::setFixedCost(const double & value);
\end{lstlisting}
By default, the fixed cost is equal to zero. For example, in the bin packing model, the fixed cost of the knapsack
subproblem may be set to $1.0$. The same \verb+setFixedCost+ method is defined for \verb+BcColGenSpArray+. It sets the
same fixed cost for all subproblem formulations in the array.

The master formulation can be initialized with a set of columns using two methods of \verb+BcFormulation+: 
\begin{lstlisting}
void initializeWithSolution(BcSolution & sol);
void initializeWithColumns(BcSolution & sol);
\end{lstlisting}
These two methods should be called after completely defining the master and subproblem formulations. The solution passed
should be disaggregated (see Section~\ref{sec:solution}). The first method updates the global solution of the model
and adds its subproblem solutions as columns to the restricted master problem (if parameterized accordingly, see
Section~\ref{sec:colgenconfig}). The second method adds columns corresponding to subproblem solutions in the provided
solution chain \verb+sol+ to the restricted master problem (independently of the parameterization and without updating
the global solution of the model).

If one wants to solve a MIP model without applying decomposition, a single formulation should be declared using
constructor
\begin{lstlisting}
BcFormulation(BcModel & model, const std::string & name = "directForm");
\end{lstlisting}
Then, instead of solving the model, one should solve this formulation using method
\begin{lstlisting}
BcSolution BcFormulation::solve(); 
\end{lstlisting}

\subsection{Variables and constraints}
\label{sec:varconstr}

Variables and constraints are defined using arrays:
\begin{lstlisting}
BcVarArray(const BcFormulation & formulation, const std::string & name);
BcConstrArray(const BcFormulation & formulation, const std::string & name = "");
\end{lstlisting}
Every array of variables or constraints should belong to a formulation, either to the master or the a subproblem
one. Note that these constructors are used in two ways. First, one can create a new array of variables or constraints
before solving the model. After starting the solution process, one can retrieve the existing array by passing its name
as the parameter.  This functionality is used to retrieve existing variables and constraints in user-defined functors.

The same operators \verb+operator()+ and \verb+operator[]+ as for formulations are used to access individual elements in
the array. Again, the first operator creates the element with given indices if it does not exist, the second operation
raises an error in this case. Note that the syntax of these operators is different for multi-dimensional indices:
\begin{lstlisting}
BcVarArray xVar(colGenSp[0], "X");
xVar(0,0); 
xVar[0][0] <= 1; 
\end{lstlisting}
This code creates variable $x_{0,0}$ belonging to the subproblem formulation with index $0$, and then sets the upper
bound of this variable to $1$. The type of individual variables is \verb+BcVar+, and the type of individual constraints
is \verb+BcConstr+. 


For an array of variables or constraints, one can define index characters:
\begin{lstlisting}
xVar.defineIndexNames(MultiIndexNames('i','j'));
\end{lstlisting}
This characters are used in names of individual variables. For example, the name of variable \verb+xVar[0][0]+ will be
\verb+"Xi0j0"+.
 
For an array of variables, their type is set using method \verb+type+:
\begin{lstlisting}
xVar.type('B');
\end{lstlisting}
\verb+'B'+ stands for binary, \verb+'I'+ for integer, and \verb+'C'+ for continuous. By default, variables are
continuous. The same method is also defined for individual variables. 

For an array of variables, or individual variables, one can define their bounds using operators \verb+operator<=+ and
\verb+operator>=+. For subproblem variables these bounds are \emph{local} and valid only when solving the subproblem. In
the global model solution, the total value of a subproblem variable can violate its local bounds. To set global
bounds on subproblem variables, one should define the corresponding master constraints.

For an array of constraints, or individual constraints, one can define their sense and right-hand size using operators
\verb+operator<=+, \verb+operator>=+, and \verb+operator==+. For example the code 
\begin{lstlisting}
BcConstrArray setPackConstr(master(), "SPC");
setPackConstr(0) <= 1; 
\end{lstlisting}
creates a less-or-equal constraint with the right-hand-size value equal to $1$.

For an array of constraints, or individual constraints, one can indicate whether they will be used in preprocessing,
using method
\begin{lstlisting}
void toBeUsedInPreprocessing(bool flag);
\end{lstlisting}

To set coefficients of variables in constraints, one may use operators \verb_operator+=_, \verb_operator+_,
\verb_operator-=_, and \verb_operator-_. For example, the code
\begin{lstlisting}
BcConstrArray setCovConstr(master(), "SCC");
setCovConstr.defineIndexNames(MultiIndexNames('k'));
setCovConstr(0) >= 2; 
BcVarArray yVar(master(), "Y");
setCovConstr[0] += xVar[0][0] + 2 * y[0]; 
setCovConstr[0] -= 0.5 * xVar[0][0]; 
\end{lstlisting}
defines constraint $\frac{1}{2}x_{0,0} + 2y_0 \geq 2$ with name \verb+"SCCk0"+.

\subsection{Objective function}
\label{sec:objective}

The objective function of a model or a formulation (when solving a MIP) can be obtained using the constructors
\begin{lstlisting}
BcObjective(BcModel & model);
BcObjective(BcFormulation & bcForm);
\end{lstlisting}

The sense and integrality of the objective function is determined using the method
\begin{lstlisting}
void setMinMaxStatus(const BcObjStatus::MinMaxIntFloat & newObjectiveSense);
\end{lstlisting}
Possible arguments are \verb+BcObjStatus::minInt+ and \verb+BcObjStatus::minFloat+. One may not use maximization
objective with \bc for the moment, as there are known bugs when it is used. One can transform maximization objective to
minimization by multiplying it by $-1$. By default, the objective function is ``float'', which mean it can take any
value. If it is known that the objective function value of any feasible solution is integer, one should give this
information to the solver by setting the objective function type to ``integer''. In this case, the lower bound will be
rounded up before checking whether a branch-and-bound node should be pruned, making the search tree smaller.

Coefficients of the variables in the objective function are set in the same way as for constraints. For example, the
code
\begin{lstlisting}
BcObjective objective(model);
objective.setMinMaxStatus(BcObjStatus::minInt);
objective += yVar(0) + 2 * yVar(1);
\end{lstlisting}
sets the objective function to $\min y_0 + 2y_1$ and states that it can take only integer values. Both master and
subproblem variables may participate in the objective function. 

The initial upper bound for the objective function value (i.e. the cut-off value) can be set using operator
\verb+operator<=+. For example, the code
\begin{lstlisting}
objective <= 100;
\end{lstlisting}
sets the cut-off value to 100, meaning that all branch-and-bound nodes will be pruned as soon as the lower bound becomes
strictly greater than 99 (as the objective function is known to be integer as indicated above). Setting initial upper
bound to a value which is as close as possible to the optimum value is important to decrease the size of the search tree.

Another important method sets the initial coefficient of artificial variables in the objective function:
\begin{lstlisting}
void setArtCostValue(const double & cost);
\end{lstlisting}
In some cases, \bc may wrongly declare the model infeasible if the value of this coefficient is below the optimum
value. Therefore, a good practice is to set this coefficient to a known upper bound on the optimum solution
value. Decreasing the value of this coefficient may help to avoid numerical issues when they are present.

\subsection{Solution handler}
\label{sec:solution}

In \bc modelling interface, solutions are stored using handlers of type \verb+BcSolution+. This handler may contain either
a single solution or several solutions in a chain. The constructor of this handler is
\begin{lstlisting}
BcSolution(const BcFormulation & formulation);
\end{lstlisting}

Each solution belongs to a formulation. A solution of a subproblem formulation defines the corresponding column in the
restricted master problem. To set a value of a variable in the solution, operators \verb+operator=+ and
\verb_operator+=_ is used. For example, the code
\begin{lstlisting}
BcSolution bcSol(colGenSp[0]);
x[0][0] = 2;
bcSol += x[0][0];
\end{lstlisting}
defines a solution $x_{0,0} = 2$ (all other variables take value $0$) for the subproblem formulation with index $0$.

To add a solution to the solution chain, one can use method
\begin{lstlisting}
BcSolution & appendSol(BcSolution & sol);
\end{lstlisting}
This method is useful, when one needs to pass several solutions. For example, the user-defined pricing problem solver
may return several solutions so that multiple columns are added to the restricted master LP in a single column
generation iteration.

To read all solutions in a solution chain, the following methods are useful:
\begin{lstlisting}
BcSolution next() const;
bool defined() const;
\end{lstlisting}
One can obtain next solution in a loop until the current solution is not defined.

To retrieve the variables with non-zero values in a solution, one can use methods
\begin{lstlisting}
void extractVar(std::set< BcVar > & varSet);
void extractVar(const std::string & genericName, std::set< BcVar > & varSet);
\end{lstlisting}
The first method retrieves all non-zero variables in the solution. The second one retrieves only variables in the array
with the given name. Once the non-zero variables are extracted, values of particular variables can be obtained using
method
\begin{lstlisting}
double BcVar::solVal() const;
\end{lstlisting}

Solutions of the master formulation can be standard (or \emph{aggregated}) and \emph{disaggregated}. A standard solution
has values of all variables, both master and subproblem ones, in the aggregated form. This means that the value of a
subproblem variable in this solution is the weighted sum of values of this variable in solutions corresponding to
columns, where weights are values of the columns in the master solution. A disaggregated solution is a chain of
solutions, where the first solution contains values of pure master variables, and all other solutions in the chain
correspond to columns in the master solution. For every such solution in the chain, one can retrieve the subproblem
solution it belongs to and its multiplicity, i.e. the value of the corresponding column in the master solution:
\begin{lstlisting}
BcFormulation formulation() const;
int getMultiplicity() const;
\end{lstlisting}
By default, the solution returned by the solver is disaggregated.

\subsection{Branching}
\label{sec:branching}

One can use three types of branching in \bc: branching on variables, branching on constraints, and custom
``algorithmic'' branching (with user-defined functors). 

To branch on variables, one needs to define their branching priorities. For that, the following methods exists
for an array of variables
\begin{lstlisting}
const BcVarArray & priorityForMasterBranching(double priorityValue);
const BcVarArray & priorityForSubproblemBranching(double priorityValue);
const BcVarArray & priorityForRyanFosterBranching(double priorityValue);
\end{lstlisting}
If the branching priority value is non-positive, the corresponding branching strategy is not applied. Default priority
values for master branching, subproblem branching, and Ryan\&Foster branching are 1.0, 0.1, and -1.0. The corresponding
variable branching strategies are: 1) branching in master on the total value of the variable; 2) Vanderbeck branching on
bounds of subproblem variables, proposed in~\cite{Vanderbec:11a}; 3) Ryan\& Foster branching, proposed
in~\cite{RyanFoster:81a}. It suffices to use only the first branching strategy if the upper bound of all subproblem
formulations is one, i.e. in the absence of identical subproblems. Otherwise, if all subproblem variables are binary,
Ryan\& Foster branching may be used. In the most general case (identical subproblems with general integer subproblem
variables), the second branching strategy should be used to ensure the exact solution. If the pricing functor is used
for a subproblem, it should explicitly support Ryan\& Foster branching in order to use it. The pricing functor needs to
support arbitrary bounds on subproblem variables in order to use Vanderbeck branching. Finally, we advise to use
Vanderbeck branching only if it is really needed, as we will not likely be able to correct possible bugs in the
implementation. For variables which belong to the master formulation, only the first branching strategy is
possible.

To branch on constraints, one should define array(s) of branching constraints using constructor
\begin{lstlisting}
BcBranchingConstrArray(const BcFormulation & formulation,
		       const std::string & name,
		       const SelectionStrategy & priorityRule 
                             = SelectionStrategy::MostFractional,
                       const double & priorityLevel = 1.0);
\end{lstlisting}
Here the \verb+priorityLevel+ is the branching priority value of all constraints in this array. After creating the
array, branching constraints can be defined in the same way as standard constraints, see
Section~\ref{sec:varconstr}. The only difference is that the sense and the right-hand-size of branching constraints are
ignored. Branching constraints are not added to the formulation in the beginning of the solution process. During
branching, the left-hand-side value $v$ of each branching constraint is computed using the current solution of the
restricted master LP. In the case $v$ is fractional, two constraints with the same left-hand-size are generated for two
child nodes of the branch-and-bound tree: one is less-or-equal to $\lfloor v\rfloor$, and the second is greater-or-equal
to $\lceil v\rceil$.

To add a custom ``algorithmic'' branching strategy one should define a functor which inherits from class
\verb+BcDisjunctiveBranchingConstrSeparationFunctor+ and associate it to an array of branching constraints (such an array
should not contain any pre-defined branching constraints) using method
\begin{lstlisting}
const BcBranchingConstrArray & 
      attach(BcDisjunctiveBranchingConstrSeparationFunctor 
             * separationRoutinePtr);
\end{lstlisting}
The functor should implement the following operator
\begin{lstlisting}
bool operator()(BcFormulation formPtr,
		BcSolution & primalSol,
		const int & candListMaxSize,
		std::list<std::pair<BcConstr, std::string>> 
                & retBrConstrList);
\end{lstlisting}
This function receives the master formulation handler, the solution handler which contains the current solution of the
restricted master LP, and the maximum number of branching constraints which will be processed (others will be
ignored). All branching constraints generated should be added to list \verb+retBrConstrList+ of pairs. The first member
of the pair is the branching constraint generated, and the second member is its description string. The description
string is used to recognise the same branching constraint when collecting the branching history. The branching history
is used to select good branching candidates in the strong branching. In the function, the branching constraints should
be defined in the same way as above (their sense and right-hand-side are ignored). The function should return
\verb+true+ if and only if at least one branching constraint has been added to \verb+retBrConstrList+.

All defined branching strategies are applied in decreasing order of their branching priority values. If no branching
candidate is found for branching strategies with a certain priority value, strategies with the next lower priority value
will be tried. If strong branching is used (see Section~\ref{sec:strongbranchingconfig} for parameterization), branching
strategies with lower priority are tried only if the number of generated branching candidates is lower than the required
number of candidates. One particularity is that, if at least one branching candidate is found, then branching strategies
with lower priority are tried only if their priority value is not smaller than the priority value of the found
candidates rounded down.

\subsection{Separation of cutting planes}
\label{sec:cutseparation}

A family of cutting planes can be defined using constructor
\begin{lstlisting}
BcCutConstrArray(const BcFormulation & formulation,
                 const std::string & name,
                 const char & type = 'F',
                 const double & rootPriorityLevel = 1.0,
                 const double & nonRootPriorityLevel = 1.0);
\end{lstlisting}
A family of cutting plains is similar to an array of constraints. The difference is that the cuts are added during the
solution process by the cut separation functor. Two important parameters of the constructor are \verb+type+ and
\verb+priorityLevel+. ``Facultative'' cuts (type \verb+'F'+) are cuts which are separated only for fractional
solutions. ``Core'' cuts (type \verb+'C'+) are separated both for fractional and integer solutions, similarly to lazy
constraints. Families of cuts are separated in the decreasing order of their priority level. A family of cuts with the
next lower priority level is separated only if no cuts from families of higher priority level could not be separated or
if the tailing-off condition for cuts with the previous higher priority level was reached. The parameterisation of the
tailing-off condition in given in Section~\ref{sec:cutgenconfig}. Priority level of the cut families may be different in
the root node. The following method can be used to set the root priority level:
\begin{lstlisting}
void setRootPriorityLevel(const double & rootPriorityLevel);
\end{lstlisting}

To add a custom cut separation procedure for a family of cuts, one should define a functor which inherits from class
\verb+BcCutSeparationFunctor+ and associate with the cut family using the method
\begin{lstlisting}
const BcCutConstrArray & attach(BcCutSeparationFunctor 
                                * separationRoutinePtr);
\end{lstlisting}
The functor should implement the following operator
\begin{lstlisting}
int operator()(BcFormulation formPtr,
	       BcSolution & primalSol,
	       double & maxViolation,
	       std::list< BcConstr > & cutList);
\end{lstlisting}
This function receives the master formulation handler, the solution handler which contains the current solution of the
restricted master LP. Parameter \verb+maxViolation+ should be ignored. All generated cutting planes should be added to
list \verb+cutList+. The cutting planes are defined in the
same way as normal constraints. This functor should return the number of cutting planes added to \verb+cutList+.

Separation of non-robust cuts and taking into account non-robust cuts when solving the pricing problem is reserved for
advanced use. Please contact the authors if you want to use this functionality.

\subsection{Pricing functor}
\label{sec:pricing}

To solve the pricing problem by a user-defined algorithm, one should define a pricing functor which inherits from class
\verb+BcSolverOracleFunctor+ and attach it to the corresponding subproblem formulation using method
\begin{lstlisting}
const BcFormulation & attach(BcSolverOracleFunctor * oraclePtr);
\end{lstlisting}

For a pricing functor, one may implement several functions which are called in different moments of the solution
process. The main function \verb+operator()+ serves to solve the pricing problem in each iteration of the column
generation procedure:
\begin{lstlisting}
bool operator()(BcFormulation spForm,
                int colGenPhase, 
                double & objVal,
                double & dualBound,
                BcSolution & primalSol);
\end{lstlisting}
This function receives the subproblem formulation handler. All the information needed for solving the pricing problem
can be retrieved using this handler. The only additional information passed by function arguments is \verb+colGenPhase+,
which is the current column generation phase. Phase zero is the exact phase, and phases one and above are heuristic
phases. More information about the column generation phases is given in Section~\ref{sec:colgenconfig}. The function
should return the best solution value found in \verb+objVal+, the lower bound on the solution value in \verb+dualBound+,
and the best found solution in \verb+primalSol+. If \verb+colGenPhase+ is equal to $0$ and the pricing problem is solved
to optimality, then values of \verb+objVal+ and \verb+dualBound+ should all be equal. If \verb+colGenPhase+ is equal to
$0$ then \verb+dualBound+ should be equal to a valid lower bound on the optimal solution of the pricing problem,
otherwise the optimality of the solution found by \bc is not guaranteed. If multiple solutions are found, they can be
added to \verb+primalSol+ by using method \verb+appendSol()+, see Section~\ref{sec:solution}. The function should return
\verb+true+ if and only if at least one solution to the pricing problem has been found.

To obtain current information about variables of the subproblem formulation, one needs to retrive these variables
(\verb+BcVar+ handlers) using subproblem formulation handler \verb+spPtr+, the \verb+BcVarArray+ constructor and operator
\verb+operator[]+ (see Section~\ref{sec:varconstr}). The following methods of \verb+BcVar+ are used:
\begin{lstlisting}
double BcVar::curCost() const;
double BcVar::curLb() const;
double BcVar::curUb() const;
\end{lstlisting}
The first method retrieves the current reduced cost of the variable, the other two retrieve the current lower and upper
bounds on the values of this variable in any feasible solution of the pricing problem. These bounds may be changed by the
preprocessing or by branching constraints (if Vanderbeck branching is used, see Section~\ref{sec:branching}). If the
algorithm for solving the pricing problem does not support modified bounds on variable values, the preprocessing should
be turned off (or at least the preprocessing of subproblem formulations, see parameterisation in
Section~\ref{sec:mainconfig}), and Vanderbeck branching should not be used.

The pricing problem solved by the user-defined functor should not take into account the dual values of the master
convexity constraints. Therefore, a solution to the pricing problem with a negative value does not necessarily
corresponds to a column with a negative reduced cost. The solution value which corresponds to the zero reduced cost in
the current column generation iteration can be obtained by the method
\begin{lstlisting}
double BcFormulation::zeroReducedCostThreshold() const;
\end{lstlisting}

A useful function which may be implemented for the pricing functor is 
\begin{lstlisting}
bool prepareSolver();
\end{lstlisting}
This function is called after building the model and may be used to initialize the pricing functor. The function should
return \verb+true+ if and only if the pricing functor initialization succeeds. 

Two more useful functions of the functor are
\begin{lstlisting}
BcSolverOracleInfo * recordSolverOracleInfo(const BcFormulation spPtr);
bool setupNode(BcFormulation spPtr, const BcSolverOracleInfo * infoPtr);
\end{lstlisting}
The first function is called at the end of a node in the branch-and-bound tree. It can be used to save the current state
of the pricing functor to a structure or class which inherits from \verb+BcSolverOracleInfo+. The second function is
called before treating any node in branch-and-bound tree except the root node. This function receives as an argument the
pointer to the structure created by the first function at the end of the parent node. So, these two functions are
typically used to ensure that the state of the pricing functor is restored to the state of the parent node when the
solution process goes from one node in the branch-and-bound tree to another. The second function is also used to
retrieve the current set of active Ryan\&Foster constraints For this, the following method of \verb+BcFormulation+ is
used:
\begin{lstlisting}
void getRyanAndFosterBranchingConstrsList(
     std::list<BcRyanAndFosterBranchConstr> 
                              & ryanFostBranchConstrList) const;
\end{lstlisting}
Function \verb+setupNode()+ should return \verb+true+ if and only if the pricing problem becomes infeasible (for example
because of non-compatibility of Ryan\&Foster branching constraints).

Other functions of the pricing functor are reserved for advanced use. Please contact the authors if you want to use such
functionality as the subproblem variable fixing based on reduced costs, enumeration of proper columns (for example,
enumeration of elementary routes), a dynamic adjustment of the subproblem relaxation, or influencing cut separation from
the pricing problem.
 
\section{\bc configuration}
\label{sec:config}

This section lists the most important parameters of \bc. These parameters should be put to the \bc configuration file,
see Section~\ref{sec:launchapp}. If a parameter is missing in the configuration file, BaPCod will its default value,
shown below.

\subsection{Main parameters}
\label{sec:mainconfig}

\lstset{style=comstyle}

\begin{lstlisting}
GlobalTimeLimitInTick = 2147483645 # Time limit in ticks 
\end{lstlisting}
If you want to set the time limit in seconds, use the parameter
\begin{lstlisting}
GlobalTimeLimit = 0 # Time limit in seconds to solve the model 
\end{lstlisting}
Parameter \verb+GlobalTimeLimitInTick+ is used only if \verb+GlobalTimeLimit = 0+.

\begin{lstlisting}
MipSolverMaxBBNodes = 2000000 # max. nodes number for the MIP solver
MipSolverMaxTime = 360000 # time limit in seconds for the MIP solver
MipSolverMultiThread = 0 # number of threads for the MIP solver
\end{lstlisting}
These options are valid for the underlying MIP solver, which is used to solve the pricing problems (if \bc is
parameterized for that), the restricted master problem as a MIP in the corresponding heuristic, and the enumerated
master (if the pricing functor supports subproblem solution enumeration). If the value of parameter
\verb+MipSolverMultiThread+ is equal to \verb+0+ then the number of threads is determined automatically by the
underlying MIP solver. \bc itself does not use parallelisation. Therefore, setting parameter \verb+MipSolverMultiThread+
to \verb+1+ makes the whole solution process to use a single thread.

\begin{lstlisting}
OptimalityGapTolerance = 1e-6
\end{lstlisting}
If the relative gap between lower and upper bound is below this value, the column generation procedure terminates. Also,
the node is pruned in the branch-and-bound tree if the relative difference between the global upper bound and the lower
bound of the node is below this tolerance.

\begin{lstlisting}
ApplyPreprocessing = true # use pre-processing or not
PreprocessVariablesLocalBounds = true # adjust bounds of subprob. vars or not
\end{lstlisting}
By default, \bc pre-processes both master and subproblem formulations. This procedure adjusts bounds of variables and
deactivates redundant constraints. The second parameter determines whether bounds of subproblem variables are adjusted
or not. This parameter should be set to \verb+false+ if a user-defined pricing problem functor is used and it does not
support changing bounds on values of subproblem variables. The performance of the diving heuristic may be significantly
reduced if the preprocessing in the subproblems is switched off. 

\begin{lstlisting}
MaxNbOfBBtreeNodeTreated = 100000 
treeSearchStrategy = 1 
OpenNodesLimit = 1000 # max. number of nodes in breadth-first strategy
\end{lstlisting}
The first parameter here limits the total number of explored nodes in the \bc branch-and-bound tree.  There are primary
and secondary branch-and-bound trees. The second parameter can take two values: \verb+0+ (``breadth-first'' exploration
strategy for the primary tree, i.e. the open node with the smallest lower bound is considered next), and \verb+1+
(``depth-first' exploration strategy for the primary tree, the open node with the largest depth is considered
first). Parameter \verb+OpenNodesLimit+ sets the maximum number of open nodes in the primary tree. When this limit is
reached, newly created nodes are pushed to the secondary branch-and-bound tree, which is always explored in the
``depth-first'' manner. We return to the primary tree when the secondary one becomes empty.

\begin{lstlisting}
DEFAULTPRINTLEVEL = -1 # verbosity of the BaPCod output
\end{lstlisting}
Possible values here are \verb+-2+ (no output except errors and important warnings), \verb+-1+ (reduced output, one line
per 10 column generation iterations), \verb+0+ (standard output, one line per one column generation iteration). Positive
values are not recommended as the output quickly becomes overwhelming. More details about output are given in
Section~\ref{sec:output}. 

\begin{lstlisting}
solverName = CPLEX_SOLVER # underlying LP and MIP solver
\end{lstlisting}
Can be set to \verb+CLP_SOLVER+ if BaPCod was appropriately configured by Cmake (see \verb+README.md+ file for instructions). Note that certain BaPCod features cannot be used with CLP solver, as the latter is not a MIP solver. Also the overall performance may be degraded.

\subsection{Column generation parameters}
\label{sec:colgenconfig}

\begin{lstlisting}
SolverSelectForMast = a # algorithm to solve the restricted master LP
\end{lstlisting}
Possible values here are \verb+a+ (automatic LP solver), \verb+p+ (primal simplex method), \verb+d+ (dual simplex
method), \verb+b+ (barrier method without crossover), and \verb+c+ (barrier method with crossover).

\begin{lstlisting}
colGenSubProbSolMode = 2 # algorithm to solve the pricing problems
\end{lstlisting}
Possible values here are \verb+2+ (MIP solver) and \verb+3+ (user-defined pricing functor). By default, the pricing is
solved by the MIP solver, even if the pricing functor is defined. In the case \verb+colGenSubProbSolMode = 3+, the
constraints of subproblem formulations are ignored, and thus their definition may be skipped.

\begin{lstlisting}
mastInitMode = 3 # restricted master problem initialization mode
\end{lstlisting}
Possible values here are \verb+1+ (global artificial variables), \verb+3+ (local artificial variables), \verb+4+
(columns from the initial solution provided by the user), \verb+5+ (columns from the initial solution and global
artificial variables), \verb+6+ (columns from the initial solution and local artificial variables).  

\begin{lstlisting}
ArtVarPenaltyUpdateFactor = 2.0 # artificial vars cost update factor
ArtVarMaxNbOfPenaltyUpdates = 5 # max. number of updates of these costs
\end{lstlisting}
If artificial variables participate in a solution of the master problem, their coefficients in the objective
function are multiplied by the value of parameter \verb+ArtVarPenaltyUpdateFactor+. The maximum number of such
multiplications is defined by parameter \verb+ArtVarMaxNbOfPenaltyUpdates+. If this number is reached, \bc switches to
pure Phase 1 of the column generation procedure (the objective function is changed to minimizing the sum of values of
artificial variables). If the artificial variables cannot be pushed out of the solution in pure Phase 1, the master
problem is declared to be infeasible.

\begin{lstlisting}
MaxNbOfStagesInColGenProcedure = 1 # number of col. gen. phases 
\end{lstlisting}
Column generation phases are used to specify several algorithms for solving the pricing problems (only in the case the
pricing functor is defined). Usually, during phase zero, the pricing problems are solved exactly, and the larger is the
phase number, the ``lighter'' is the heuristic algorithm applied. The stages are solved successively, from phase
\verb+MaxNbOfStagesInColGenProcedure+$-1$ to phase zero. Column generation procedure passes to phase $k-1$ once phase
$k$ has converged.

\begin{lstlisting}
GenerateProperColumns = false # generate only "proper" columns or not
\end{lstlisting}
If this parameter is set to true, the pricing problem is restricted to generate only so-called "proper" columns,
i.e. columns which respect bounds on the subproblem variables. In this case, \bc will generate an error if the pricing
problem generates a non-proper column. Generating only proper columns usually improves the Lagrangian dual bound
produced by column generation. Setting this parameter to true is necessary if one uses generic subproblem branching
(Vanderbeck branching). Setting this parameter to true is also necessary if one uses a diving-based primal heuristic
(unless a heuristic pricing oracle generating proper columns is provided).

\begin{lstlisting}
InsertAllGeneratedColumnsInFormRatherThanInPool = true
\end{lstlisting}
If this parameter is true, all generated columns are inserted directly in the restricted master LP, otherwise only the
one with the smallest reduced cost (among columns corresponding to solutions of the same subproblem formulation) is
inserted.

\begin{lstlisting}
InsertNewNonNegColumnsDirectlyInFormRatherThanInPool = true
\end{lstlisting}
If this parameter is true, all generated columns are inserted directly in the restricted master LP, otherwise only
columns with negative reduced cost are inserted. 

\begin{lstlisting}
ColumnCleanupThreshold = 10000
ColumnCleanupRatio = 0.66
\end{lstlisting}
Once the number of columns in the restricted master LP exceeds\\ \verb+ColumnCleanupThreshold+, only
\verb+ColumnCleanupRatio+ part of them (with smallest reduced cost) remain, and the others are removed. The columns
participating in the basis of the restricted master LP are never removed.

\begin{lstlisting}
ReducedCostFixingThreshold = 0.9
\end{lstlisting}
This is the parameter to determine how often the reduced cost fixing procedure of the pricing functor is called.
It is called if the current integrality gap is less than \verb+ReducedCostFixingThreshold+ part relative to the
integrality gap when the reduced cost fixing procedure was called the last time. If the value is equal to \verb+0.0+, no
reduced cost fixing is performed. If the value is equal to \verb+1.0+, reduced cost fixing is called after each
convergence of the column generation prodedure. 

\subsection{Cut generation parameters}
\label{sec:cutgenconfig}

\begin{lstlisting}
MasterCuttingPlanesDepthLimit = 1000 # max. tree depth for cut generation
MaxNbOfCutGeneratedAtEachIter = 1000 # max. number of cuts added per cut round
\end{lstlisting}
These are main parameters to determine when cut separation routines are called (set the first parameter to \verb+-1+ to
switch off cut generation) and how much cuts are added at each cut separation round (the upper limit on the overall
number of cuts from all cut separators).

\begin{lstlisting}
CutCleanupThreshold = 1 
\end{lstlisting}
If the number of cuts reaches this threshold, all non-active cuts are removed from the restricted master LP.

\begin{lstlisting}
CutTailingOffThreshold = 0.02
CutTailingOffCounterThreshold = 3
\end{lstlisting}
These parameters are used to control the tailing-off condition of cut separation. The tailing-off counter is initialized
with zero in the beginning of each branch-and-bound node. After a cut generation round, if the relative decrease of the
integrality gap is smaller than the value of \verb+CutTailingOffThreshold+, then the tailing-off counter is increased by
one. If the previous relative integrality gap is more than 10\%, then the decrease calculated is relative from the lower
bound absolute value multiplied by $0.1$. When the tailing-off counter reaches the value of
\verb+CutTailingOffCounterThreshold+, the tailing-off condition is activated: the cut separators with smaller priority
are called if they are defined, or branching is performed.

\subsection{Stabilization parameters}
\label{sec:stabconfig}

Implementation of stabilization techniques in BapCod follows the paper~\cite{PessoaSadykovUchoa:18b}. Please cite it if
you use stabilization. By default, only the automatic dual price smoothing stabilization is activated. 

Dual price smoothing parameters are the following.
\begin{lstlisting}
colGenDualPriceSmoothingAlphaFactor = 1.0
colGenDualPriceSmoothingBetaFactor = 0.0
\end{lstlisting}
These two parameters correspond to parameters $\alpha$ and $\beta$ introduced in the paper. The first parameter
corresponds to Wentges smoothing~\cite{Wentges:97a} and the second parameter corresponds to directional smoothing. Value
\verb+0.0+ means that the technique is not used. Value \verb+1.0+ means that the technique is used with automatic
parameter setting. Any value in $(0, 1)$ fixes the corresponding parameter to this value.

Piecewise linear penalty function stabilization~\cite{Ben-AmorDesrosierFrangioni:09a} parameters are the following.
\begin{lstlisting}
colGenStabilizationFunctionType = 0
colGenProximalStabilizationRule = 1
StabilFuncKappa = 1.0
\end{lstlisting}
The first parameter sets the stabilization function type: \verb+0+ (penalty function stabilization is not used),
\verb+2+ (3-piecewise linear function is used), \verb+3+ (5-piecewise linear function). The second parameter switches
between the ``curvature mode'' (value \verb+0+) and ``explicit mode'' (value \verb+1+),
see~\cite{PessoaSadykovUchoa:18b} for details. The third parameter sets the value for parameter $\kappa$ introduced in
the paper. The penalty function stabilization should be used with caution as it may deteriorate the column generation
performance. We advice to use 3-piecewise linear function stabilization in ``explicit mode'' (only in the case of severe
convergence problems). Parameter $\kappa$ is very dependent on the problem at hand and even on the instance. Its value
may vary broadly, from $0.001$ to $1000$ and sometimes even more.  

Additional stabilization parameters are
\begin{lstlisting}
colGenStabilizationMaxTreeDepth = 10000
StabilizationMinPhaseOfStage = 0
\end{lstlisting}
One can limit the stabilization use only to nodes at maximum depth\\ \verb+colGenStabilizationMaxTreeDepth+ in the
branch-and-bound tree. One can also limit the stabilization use only to column generation phases with number
\verb+StabilizationMinPhaseOfStage+ and above.

\subsection{Primal heuristic parameters}
\label{sec:heurconfig}

Implementation of primal heuristics in BapCod follows the paper~\cite{SadykovVanderbecPessoa:19a}. Please cite it if you
use heuristics. No heuristic is activated by default.

Parameters for the restricted master heuristic are the following
\begin{lstlisting}
MaxTimeForRestrictedMasterIpHeur = -1
CallFrequencyOfRestrictedMasterIpHeur = 0
MIPemphasisInRestrictedMasterIpHeur = 1
PolishingAfterTimeInRestrictedMasterIpHeur = -1
\end{lstlisting}
The first parameter sets the maximum time in seconds for the MIP solver called to solve the restricted master MIP. The
second parameter sets the frequency of the heuristic. Its value should be \verb+1+ to call it at every node of the
branch-and-bound tree. The heuristic is called only at the root node if the value of the second parameter is not
positive. The last two parameters correspond to parameters \verb+CPX_PARAM_MIPEMPHASIS+ and
\verb+CPX_PARAM_POLISHAFTERTIME+ of the Cplex MIP solver. The restricted master heuristic cannot be used with CLP solver.

Parameters for the variants of the diving heuristic are the following
\begin{lstlisting}
DivingHeurUseDepthLimit = -1 
CallFrequencyOfDivingHeur = 0
\end{lstlisting}
The first parameter sets the maximum depth in the branch-and-bound tree for using the diving heuristic. If its value is
negative, diving heuristic is not used. The second parameter is equivalent to \verb+CallFrequencyOfRestrictedMasterIpHeur+.

\begin{lstlisting}
RoundingColSelectionCriteria = 4 6 9
\end{lstlisting}
This parameter determines the criteria for column selection for rounding. This parameter should be initialized with a
chain of integers separated by spaces. Each integer corresponds to a certain criterion. A criterion is used only if
all previous ones could not select the column for rounding. The criteria are:
\begin{description}
\item[ 2 -] highest priority (a column from a higher priority subproblem is preferred)
\item[ 4 -] smallest distance to the closest non-zero integer
\item[ 5 -] distance to the closest non-zero integer weighted by the column cost
\item[ 6 -] closest value to its round-up
\item[ 9 -] least column cost
%\item[10 -] distance to the closest non-zero integer weighted by the column reduced cost
\end{description}

\begin{lstlisting}
FixIntValBeforeRoundingHeur = true
\end{lstlisting}
If set to true, then any column with integer value in the solution will be fixed before rounding a non-integer
column. Otherwise, integer columns will be ignored (and thus may take different values later in the dive).

\begin{lstlisting}
MaxNbOfCgIteDuringRh = 5000
\end{lstlisting}
This parameter limits the number of column generation iterations in each node of the diving heuristic.

\begin{lstlisting}
MaxLDSbreadth = 0
MaxLDSdepth = 0
\end{lstlisting}
These parameters correspond to parameters \verb+maxDiscrepancy+ and \verb+maxDepth+ in the paper. If their values are
positive, they serve to control the diving heuristic with Limited Discrepancy Search.

\begin{lstlisting}
DivingHeurStopsWithFirstFeasSol = false
\end{lstlisting}
If set to true, the diving heuristic will stop as soon as it finds the first feasible solution (this behaviour
corresponds to the ``diving for feasibility'' heuristic in the paper).

\begin{lstlisting}
DivingHeurPreprocessBeforeChoosingVar = false
\end{lstlisting}
If set to true, the preprocessing will be launched after rounding of each candidate column (thus the diving will be
slower). If preprocessing determines infeasibility, the candidate will be discarded and the next one will be
considered. When this parameter is false, a dive is stopped, if the preprocessing determines the infeasibility.

\begin{lstlisting}
StrongDivingCandidatesNumber = 1
\end{lstlisting}
If the value of this parameter is greater than \verb+1+, the strong diving heuristic will be activated. This parameter corresponds to
parameter \verb+maxCandidates+ in the paper.

\begin{lstlisting}
EvalAlgParamsInDiving = 
\end{lstlisting}
This is an optional parameter sequence to set the behaviour of the column and cut generation procedure at every node of
the diving heuristic. The instantiation of this parameter is similar to the instantiation of the parameters for strong
branching phases (described in Section~\ref{sec:strongbranchingconfig}). If this parameter sequence is empty, the same
parameters are used as for the column at cut generation in the main branch-and-bound tree.

The following parameters are for the local search heuristic (corresponds to the diving heuristic with restarts in
the paper).
\begin{lstlisting}
LocalSearchHeurUseDepthLimit = -1
LocalSearchColSelectionCriteria =
LocalSearchHeurUseDepthLimit = 2
MaxFactorOfColFixedByLocalSearchHeur = 0.8
MaxLocalSearchIterationCounter = 3
\end{lstlisting}
The first parameter sets the maximum depth in the branch-and-bound tree for using the local search heuristic. If its
value is negative, the heuristic is not used. The second parameter can be set in the same way as the parameter
\verb+RoundingColSelectionCriteria+ above. The third parameter sets the maximum depth in the branch-and-bound tree for
using the local search heuristic. The last two parameters correspond to parameters \verb+fixRatio+ and
\verb+numIterations+ in the paper.

Also, the following parameters described above have an impact on the local search heuristic :
\verb+MaxNbOfCgIteDuringRh+, \verb+DivingHeurPreprocessBeforeChoosingVar+, and \verb+FixIntValBeforeRoundingHeur+.

\subsection{Strong branching parameters}
\label{sec:strongbranchingconfig}

The strong branching with phases is implemented in BapCod. Each phase has its proper parameters
given as a sequence of numbers separated by spaces :
\begin{lstlisting}
StrongBranchingPhaseOne =
StrongBranchingPhaseTwo =
StrongBranchingPhaseThree =
StrongBranchingPhaseFour =
\end{lstlisting}
The parameter sequence is empty if the corresponding strong branching phase is not active,
i.e. is not used. For each active phase the order of parameters is the following

\begin{enumerate}
\item Boolean indicating where this phase is exact or not. In the exact phase the column and cut generation parameters
  do not change. The exact phase should always be the last active phase to guarantee the optimality of the final
  solution. Candidates in an exact phase are selected using the minimum estimated tree size rule
  (see~\cite{Kullmann:09a} for a method to estimate the tree size). Candidates in a non-exact phase are selected using
  maximum product rule, i.e. according to the product of lower bound increases in the child nodes.
\item The maximum number of candidates evaluated.
\item Tree size ratio to stop : the maximum number of candidates evaluated in this phase does not exceed this value
  multiplied by the estimated size of the subtree rooted at the father node. If there is no father node (i.e. for the
  root), the latter value is equal to infinity.
\end{enumerate}

The next parameters are given only for a non-exact phase.
\begin{enumerate}[resume]
\item Maximum number of column generation iterations. If this parameter is zero, no column generation is performed,
  i.e. only re-optimization of the restricted master LP is performed.
\end{enumerate}

The next parameters are given only for a non-exact phase with column generation.
\begin{enumerate}[resume]
\item Minimum phase for the column generation
\item Minimum number of cut generation rounds
\item Maximum number of cut generation rounds
\item Boolean indicating whether the reduced cost fixing is performed.
\item The frequency of column generation output, i.e. the number of column generation iteration between two consecutive
  lines in the output. If the frequency is zero, then only one summary line is shown.
\end{enumerate}

The following is an example of instantiation of the strong branching parameters.
\begin{lstlisting}
StrongBranchingPhaseOne = false 100 0.5 0
StrongBranchingPhaseTwo = false 5 0.1 100 1 0 0 false 0
StrongBranchingPhaseThree = true 1
\end{lstlisting}
Here, during the first phase, at most $\min\{100,0.5e\}$ candidates will be evaluated, where $e$ is the estimated
subtree size of the father node, and only restricted master will be solved for them without column generation. During
the second phase, the best $\min\{5,0.1e\}$ candidates from the first phase will be evaluated. At most 100 column
generation iterations will be performed for each node of each branching candidate. During column generation, all stages
except stage zero will be considered. No cut generation and no reduced cost fixing will be performed. No column
generation statistics will be shown during this phase (only one summary line).  In the third phase, all branches of the
best candidate from the second phase will be evaluated exactly. The purpose for this immediate evaluation is to estimate
the subtree size rooted at the current node. The fourth phase is not defined and thus it is not active.

Finally, the following parameter is used to activate the simplified setting of strong branching parameters:
\begin{lstlisting}
SimplifiedStrongBranchingParameterisation = false
\end{lstlisting}
If it is set to \verb+true+, then the strong branching parameters are set to
\begin{lstlisting}
StrongBranchingPhaseOne = false <p1> <p2> 0
StrongBranchingPhaseTwo = false <p3> <p4> 10000 1 0 0 false 0
StrongBranchingPhaseThree = true 1
StrongBranchingFour = 
\end{lstlisting}
where \verb+<p1>+, \verb+<p2>+, \verb+<p3>+, and \verb+<p4>+ are set by the following parameters:
\begin{lstlisting}
StrongBranchingPhaseOneCandidatesNumber = 100   # <p1>
StrongBranchingPhaseOneTreeSizeEstimRatio = 0.3 # <p2>
StrongBranchingPhaseTwoCandidatesNumber = 3     # <p3>
StrongBranchingPhaseTwoTreeSizeEstimRatio = 0.1 # <p4>
\end{lstlisting}


\section{\bc statistics}
\label{sec:stats}

This section overviews the statistics which can be retrieved after solving the model (see Section~\ref{sec:environment})
for the methods to use.

\subsection{Timers}

The values of all timers are in ticks. To obtain the time in seconds, the value should be divided by 100.

\begin{description}
\item[bcTimeMain -] overall solution time 
\item[bcTimeBaP -] total branch-cut-and-price time (excludes formulations building time and the final solution
  disaggregation)
\item[bcTimeMIPSol -] solution time when just a MIP formulation is solved without decomposition (excludes formulations
  building time)
\item[bcTimeRootEval -] solution time of the root (excluding primal heuristics and branching)
\item[bcTime1stLP -] solution time of the first column generation convergence at the root (before cut separation)
\item[bcTimeColGen -] total column generation time (all time to solve the master problem including generation of columns)
\item[bcTimeMastMPsol -] total time taken for solving the restricted master LPs by the LP solver
\item[bcTimeCgSpOracle -] total time taken for generation of columns (computing the reduced cost of subproblem variables,
  solving the pricing problems, generating the columns from subproblem solutions, and adding columns to the restricted
  master LP including computation of column coefficients in the master constraints)
\item[bcTimeSpUpdateProb -] total time taken to compute the reduced cost of subproblem variables
\item[bcTimeSpMPsol -] total time taken to solve the pricing problems
\item[bcTimeSetMast -] total time to update the formulations of the master problem and subproblems before solving a node
\item[bcTimeSepFracSol -] total branching time, i.e. generation of branching candidates (evaluation of branching
  candidates in strong branching is not included)
\item[bcTimeCutSeparation -] total time for cut separation
\item[bcTimeAddCutToMaster -] total time for adding cuts to the restricted master LP (essentially computing coefficients
  of master variables and columns in the cuts)
\item[bcTimeRedCostFixAndEnum -] total time for reduced cost fixing and enumeration
\item[bcTimeEnumMPsol -] total time to solve enumerated MIPs
\item[bcTimeSBphase1 -] total time for evaluating branching candidates during phase one of strong branching
\item[bcTimeSBphase2 -] total time for evaluating branching candidates during phase two of strong branching
\item[bcTimePrimalHeur -] total time for running primal heuristics
\end{description}

Some times may ``intersect''. For example, primal heuristic time includes a part of column generation time (in the case
of diving heuristics). Evaluation time for branching candidates also includes a part of column generation time and a
part of solving the restricted master LPs by the LP solver. 

\subsection{Records and counters }

\begin{description}
\item[bcRecRootDb -] the lower bound obtained at the root node (rounded up if the objective function is integer)
\item[bcRecRootLpVal -] the value of the master problem solution at the root node (not rounded even if the objective
  function is integer)
\item[bcRecBestDb -] final lower bound obtained by the branch-and-bound (rounded up if the objective function is
  integer)
\item[bcRec1stLPDb -] lower bound obtained by the column generation procedure at the root (before cut separation)
\item[bcRecBestInc -] best upper bound (value of the best feasible solution found) obtained by the branch-and-bound (the
  solution is optimal if this value is equal to {\bf bcRecBestDb})
\item[bcCountCg -] total number of iterations in the column generation procedure
\item[bcCountCol -] total number of generated columns (not all columns are necessarily added to the restricted master LP)
\item[bcCountNodeProc -] total number of processed nodes in the branch-and-bound tree
\item[bcCountCutInMaster -] total number of cuts added to the restricted master LP
\item[bcCountMastSol -] total number of times the restricted master LP has been solved by the LP solver
\item[bcCountSpSol -] total number of times the pricing problems have been solved
\item[bcCountMastIpSol -] total number of times the restricted master has been solved as a MIP 
\end{description}

\section{\bc output}
\label{sec:output}

See Section~\ref{sec:mainconfig} for the parameter to change the verbosity of the \bc output. It is possible to suppress
all output except important warnings and errors. In the case the output is not suppressed, \bc will output the following
information. 

\medskip  At the beginning \bc prints its version:
\footnotesize
\begin{verbatim}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              BaPCod v063,  2/09/2021, © Inria Bordeaux, France
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{verbatim}
\normalsize 

\medskip At the beginning of every branch-and-bound node, \bc outputs the following information
\scriptsize
\begin{verbatim}
********************************************************************************************
**** BaB tree node (N° 5, parent N° 3, depth 2)
**** Local DB = 831.794, global bounds : [ 831.794 , 878.08 ], TIME = 1h22m49s40t = 496940
**** 3 open nodes, 24679 columns (8375 active), 426 dyn. constrs. (199 active), 
     559 art. vars. (332 active)
********************************************************************************************
\end{verbatim}
\normalsize The first line prints the index of the current node (indices are given in the order of node creation), index
of the father node, and the depth of the current node. The second line outputs the lower bound value of the current
node, the global lower and upper bounds (valid for the model), and the current elapsed time. The third line outputs the
current number of open branch-and-bound nodes (i.e. which were created but not yet pruned), and the aggregated
information about the restricted master problem. This information includes the total number of columns in the memory
(number of columns present in the current restricted master LP), the total number of cuts and branching constraints in
the memory (number of cuts and branching constraints present in the current restricted master LP), the total number of
artificial variables in the memory (the number of artificial variables present in the current restricted master LP). 

\medskip  During the column generation procedure, \bc outputs the following information
\scriptsize
\begin{verbatim}
#<DWph=2> <it=  1> <et=4621.25> <Mt= 0.66> <Spt= 1.66> <nCl=  3> <al=0.50> <DB=  817.8515> 
 <Mlp=  830.2749> <PB=878.08035> 
\end{verbatim}
\normalsize This information includes the current column generation phase (printed only if the number of phases is more
than one), the current column generation iteration number, the current elapsed time, the time in seconds to solve the
restricted master LP in the current iteration, the total time in seconds taken for generating columns in the current
iteration (includes the time to solve the pricing problems), the number of columns added to the restricted master LP in
the current iteration, the current dual pricing smoothing stabilization parameter $\alpha$ (if dual pricing smoothing
stabilization is activated), the value of the Lagrangian lower bound at the current iteration, the value of the current
restricted master LP (upper bound on the solution value of the master problem), and the value of the current best known
feasible solution of the model (or the initial cut-off value given if not yet improved). If artificial variables are
present in the current solution of the restricted master LP, then character \verb+#+ is printed in the beginning of the
line.

In some cases, one line is printed per several column generation iterations. This can be recognized if the iteration
numbers are not consecutive in two consecutive lines. In this case the time for solving the restricted master LP, the
time to generate columns, and the number of generated columns are aggregated for all iterations since the iteration of
the previous line (or since the beginning of the column generation procedure).

\medskip If some cuts are added during a cut separation round, \bc outputs the following information
\scriptsize
\begin{verbatim}
----- Add fac. cuts : R1C(291) SSI(3), max.viol = 0.578033, aver.viol = 0.260438, 
      sep/add took 1.43/2.13 sec. -----
19840 columns (7441 active), 797 dyn. constrs. (441 active), 1266 art. vars. (574 active)
\end{verbatim}
\normalsize This information includes whether facultative (\verb+fac.+) or core (\verb+core+) cuts were added, the
number of added cuts separately for every family, the maximum violation among added cuts, the average cut violation
among added cuts, and the times spent for separation and adding cuts to the restricted master LP in seconds. If
\verb+zero.viol = #+ is shown, then there are some generated but non-violated cuts. These may indicate the presence of a
bug in the cut separation procedure (unless non-violated cuts are intentionally generated). The same aggregated
information about the restricted master problem as in the beginning of the branch-and-bound node is also printed.

\medskip If cut separation routines are called, but no cuts were generated, \bc outputs \footnotesize
\begin{verbatim}
----- no cuts found
\end{verbatim}
\normalsize
After a cut separation round and subsequent column generation procedure, \bc outputs the relative change of integrality
gap (together with the lower bound value before the previous cut round):
\footnotesize
\begin{verbatim}
Gap improvement since the last cut separation : 0.0144399 (845.956)
\end{verbatim}
\normalsize
After reaching the tailing-off condition, \bc outputs either 
\footnotesize
\begin{verbatim}
----- Cut separators priority level decreased to 1 -----
\end{verbatim}
\normalsize
if cut separators with lower priority exist, or otherwise
\footnotesize
\begin{verbatim}
----- Cut generation is stopped due to tailing off -----
\end{verbatim}
\normalsize

\medskip After evaluation of a branching candidate in strong branching, \bc outputs the following information
\scriptsize
\begin{verbatim}
SB phase 1 cand. 9 branch on var U_1_OmastV (lhs=0.2362) : [  834.1127,   862.0468], 
                                                           score = 261.81 (h)  <et=3303.55>
\end{verbatim}
\normalsize This information includes the number of the current strong branching phase, index of the branching
candidate, description of the branching candidate (here we have branching on the value of variable $U_1$), the
left-hand-side value of the branching candidate (current value of the branching variable or the left-hand-side value of
the branching constraint), solution values for the restricted master LP for both branches, the score of the branching
candidate (the larger is the score, the better it is) and the current elapsed time. If the branching candidate was
included to the current set of candidates because of its good previous performance according to the branching history,
then character \verb+(h)+ is printed (otherwise the branching candidate was generated according to the
branching strategy used).

\medskip At the end of the solution process, the final values for global lower and upper bounds are printed together
with the overall solution time: \scriptsize
\begin{verbatim}
********************************************************************************************
Search is finished, global bounds : [ 835.602 , 835.602 ], TIME = 1h48m56s75t = 653675
********************************************************************************************
\end{verbatim}
\normalsize
If values of global bounds are equal, then the best found solution is optimal. 

\section{VRPSolver extension}
\label{sec:vrpsolver}

VRPSolver extension includes an implementation of the pricing functor which allows the user to define the subproblems as
resource constrained shortest path problems in graphs. The functor implements the bucket-graph based labeling algorithm
from paper~\cite{SadykovUchoaPessoa:21l} for solving the pricing problem, as well as the corresponding bucket arc
elimination procedure (i.e. reduced cost fixing procedure), and the elementary route enumeration
procedure~\cite{BaldacciChristofiMingozzi:08a}. VRPSolver extension also implements cut separation functors for rounded
capacity cuts~\cite{LaporteNobert:83a} and limited memory rank-1 packing cuts~\cite{PecinPessoaPoggi:17b}, as well as
packing set based Ryan-and-Foster branching, and branching over accumulated resource
consumption~\cite{PessoaSadykovUchoa:21f}. We strongly advise to read paper~\cite{PessoaSadykovUchoa:20a} before using
VRPSolver extension. Please, cite this paper if your are using the VRPSolver extension. For the moment, the extension is not open-source, and it is distributed only in the compiled form. 

\lstset{ %
  language=C++, frame=single, keywordstyle=\color{blue}, stringstyle=\color{mymauve}, commentstyle=\color{mygreen},
  basicstyle=\footnotesize\ttfamily, showlines=true, aboveskip=\bigskipamount, belowskip=\bigskipamount, frame=trBL %
}

To use VRPSolver functors, one needs to include the corresponding header file:
\begin{lstlisting}
#include "bcModelRCSPSolver.hpp"
\end{lstlisting}

\subsection{VRPSolver pricing functor}
\label{sec:vrpsolverpricing}

To create such pricing functor one should use the constructor
\begin{lstlisting}
BcRCSPFunctor(const BcFormulation & spForm);
\end{lstlisting}
Afterwards, this functor should be attached to the subproblem formulation as described in Section~\ref{sec:pricing}
(\verb+BcRCSPFunctor+ inherits from \verb+BcSolverOracleFunctor+).

The information about the resource-constrained path structure should be given by defining a graph handler of type
\verb+BcNetwork+:
\begin{lstlisting}
BcNetwork(BcFormulation & bcForm, int numElemSets = 0, 
          int numPackSets = 0, int numCovSets = 0);
\end{lstlisting}
Here \verb+bcForm+ is the subproblem to which we associate the graph. Other three arguments are the number of
elementarity sets, the number of packing sets, and the number of covering sets. These sets are used to express
elementarity, packing, and covering constraints over the arcs and/or nodes of graphs
(see~\cite{PessoaSadykovUchoa:20a}). The distance matrix for elementarity sets can be passed using the following method
of \verb+BcNetwork+:
\begin{lstlisting}
void setElemSetsDistanceMatrix(
     const std::vector<std::vector<double>> & matrix);
\end{lstlisting}

Vertices and arcs of the graph can be defined using the following methods of \verb+BcNetwork+:
\begin{lstlisting}
const BcVertex createVertex();
const BcArc createArc(int tail, int head, double originalCost);
\end{lstlisting}
Here \verb+tail+ and \verb+head+ are the indices of the tail and head vertices of the arc, and \verb+originalCost+ is
the ``pure'' cost of the arc. The coefficient of a column representing a path in a graph in the objective function is
determined not only by the ``pure'' costs of its arcs, but also by objective function coefficients of subproblem
variables mapped to the arcs (see below how to map arcs to variables). An important notice here is that a special
``cost'' subproblem variable should be communicated to the pricing functor if at least one arc has a non-zero ``pure''
cost:
\begin{lstlisting}
void BcRCSPFunctor::setPureCostBcVar(BcVar bcVar);
\end{lstlisting}
The value of this variable in the subproblem solution representing a path will be set to the total ``pure'' cost of arcs
which form the path. To define the arc cost one can alternatively map a variable to a subproblem variable (see below)
and define a coefficient of this variable in the objective function (see Section~\ref{sec:objective}).

The source and the sink of the graph can be defined using the following methods of \verb+BcNetwork+:
\begin{lstlisting}
void setPathSource(const BcVertex & vertex);
void setPathSink(const BcVertex & vertex);
\end{lstlisting}

Indices of vertices and arcs are always assigned in the order of creation of vertices and arcs (starting from
$0$). These indices can be retrieved using methods
\begin{lstlisting}
int BcVertex::ref() const;
int BcArc::ref() const;
\end{lstlisting}
Vertices and arcs can be retrieved from their indices using the following methods of the handler \verb+BcNetwork+:
\begin{lstlisting}
const BcVertex getVertex(int id) const;
const BcArc getVertex(int id) const;
\end{lstlisting}

One can add a vertex or an arc to an elementarity, packing, or covering set using the following methods defined
both for \verb+BcVertex+ and \verb+BcArc+:
\begin{lstlisting}
void setElementaritySet(int elemSetId);
void setPackingSet(int packSetId);
void setCoveringSet(int covSetId);
\end{lstlisting}
The set indices here should be not less than $0$ and smaller than the corresponding number of elementarity, packing, or
covering sets given in the constructor of \verb+BcNetwork+.


An arc can be mapped to a variable belonging to the same subproblem using the following methods of \verb+BcNetwork+:
\begin{lstlisting}
void addVarAssociation(const BcVar & newvar, const double coeff);
void arcVar(const BcVar & newvar);
\end{lstlisting}
The first method defines a mapping with an arbitrary coefficient, whereas the second method defines a standard mapping
introduced in~\cite{PessoaSadykovUchoa:20a}. The standard mapping has coefficient $1.0$. The coefficient of a column
respresenting a path in a graph in a master constraint is determined by the scalar product of the vector of coefficients
of subproblem variables in this constraint and the sum of vectors of mapping coefficients for the arcs which form the
path.

A resource can added by defining the resource handler using the constructor
\begin{lstlisting}
BcNetworkResource(const BcNetwork & bcNetwork, int id);
\end{lstlisting}
Here \verb+id+ is the index of the ressource. All resources should have different indices. By default, ressources are
secondary and disposable (see~\cite{PessoaSadykovUchoa:20a} for the definition of resource types). To define a main
resource or a non-disposable resource, please use the following methods of \verb+BcNetworkResource+:
\begin{lstlisting}
void setAsMainResource();
void setAsNonDisposableResource();
\end{lstlisting}
Consumption of a resource for an arc can be defined using the following method of \verb+BcNetworkResource+:
\begin{lstlisting}
void setArcConsumption(const BcArc & bcArc, double consumption);
\end{lstlisting}
Lower and upper bounds for the accumulated resource consumption can be defined on vertices and/or on arcs using the
following method of \verb+BcNetworkResource+:
\begin{lstlisting}
void setArcConsumptionLB(const BcArc & bcArc, double consumptionLB);
void setArcConsumptionUB(const BcArc & bcArc, double consumptionUB);
void setVertexConsumptionLB(const BcVertex & bcVertex, double consLB);
void setVertexConsumptionUB(const BcVertex & bcVertex, double consUB);
\end{lstlisting}
At most 20 resources can be defined, among which at most two can be main. The main resource with the smallest
index is used to determine the threshold for the bi-directional labeling algorithm which solves the pricing problem
(see~\cite{SadykovUchoaPessoa:21l}).  

There is a possibility to define special resources for which the accumulated resource consumption can be either $0$ or
$1$ (i.e. binary resource). These resources are declared implicitly by defining consumption of such resources on arcs
using the following method of \verb+BcArc+:
\begin{lstlisting}
void addBinaryResourceConsumption(int binaryResId, int consumption)
\end{lstlisting}
and by defining accumulated resource consumption bounds using the following methods of \verb+BcVertex+:
\begin{lstlisting}
void setBinaryResourceConsumptionLB(int binaryResId, int lowerBound);
void setBinaryResourceConsumptionUB(int binaryResId, int upperBound);
\end{lstlisting}
Here \verb+lowerBound+ and \verb+upperBound+ can take either value $0$ or value $1$. It makes sense to only define non
zero values for the (accumulated) resource consumption (bounds). The index (id) of a binary ressource can
be between $0$ and $511$. Again, by default every binary resource is disposable. To declare a binary resource
non-disposable, the following method of \verb+BcNetwork+ can be used:
\begin{lstlisting}
void setBinaryResourceNonDisposable(const int binaryResId);
\end{lstlisting}

Besides solving a \bc model with RCSP functors in the standard way, one can also enumerate all feasible paths in directed
graphs associated with subproblems:
\begin{lstlisting}
BcSolution BcModel::enumerateAllColumns(int & nbEnumColumns);
\end{lstlisting}
The total number of enumerated columns is returned in \verb+nbEnumColumns+, it is equal to -1 if enumeration did not
succeed. The enumerated solutions are returned in the solution chain, see Section~\ref{sec:solution} for details. This
method should be used for very small instances mainly for debugging and teaching purposes.


\subsection{VRPSolver cut separation functors}
\label{sec:vrpsolvercutseparation}

The rounded capacity cuts~\cite{LaporteNobert:83a} require an undirected graph $G=(V\cup\{0\},E)$ with special
``depot'' node $0$. There should be exactly one binary variable $x_e$ associated with every edge $e\in E$. A positive
demand $d_v$ should be associated with every non-depot node $v\in V$, and a positive capacity $C$ should be defined. A
rounded capacity cut is defined for a subset $S\subseteq V$ of nodes. It states that there should be enough paths
passing by set $S$ to satisfy path capacity $C$:
\begin{displaymath}
\sum_{e=(i,j):\;|\{i,j\}\cap S|=1} x_e\geq 2\cdot\left\lceil \sum_{i\in S}d_i/C\right\rceil.
\end{displaymath}

To add the functor for separation of rounded capacity cuts (the separation algorithm follows
paper~\cite{LysgaardLetchfordEglese:04a}), on should use the constructor 
\begin{lstlisting}
BcCapacityCutConstrArray(const BcFormulation & formulation,
                         const int & maxCapacity,
                         const std::vector<int> & demands,
                         const bool & isFacultative = true,
                         const bool & equalityCase = true,
                         const int & twoPathCutsResId = -1,
                         const double & rootPriorityLevel = 1.0,
                         const double & nonRootPriorityLevel = 1.0);
\end{lstlisting}
Here \verb+formulation+ is the master formulation handler, \verb+maxCapacity+ is the value for capacity $C$,
\verb+demands+ is the vector $d$ of demand values. Argument \verb+isFacultative+ determines whether cuts are facultative
(separated only for fractional solutions) or core (separated also for integer solutions). Argument
\verb+twoPathCutsResId+ should be equal to \verb+-1+. The remaining two arguments define the root and non-root
priority level (see Section~\ref{sec:cutseparation}). This cut separator is introduced in~\cite{PessoaSadykovUchoa:20a}.

The construction of undirected graph $G=(V\cup\{0\},E)$ is based on all directed graphs defined for subproblems of the
\bc model. Vertices in directed graphs defined for VRPSolver pricing functors are ``projected'' into vertices of graph
$G$. The projection is defined based on packing sets\\ (\verb+equalityCase=true+) or on covering sets
(\verb+equalityCase=false+), and on vector of demands. The first case (\verb+equalityCase=true+) should be used when
exactly one vertex in every packing set should be visited exactly once (all other vertices in the set should not be
visited). The second case (\verb+equalityCase=false+) should be used when at least on vertex in every packing set should
be visited at least once (all other vertices in the set may or may not be visited). A vertex $i$ in a directed VRPSolver
graph is projected into vertex $v\in V$ if $i$ belongs to packing/covering set $v$ and $d_v$ is positive. Otherwise, $i$
is projected into depot vertex $0$. An edge $(v,v')$ belongs to $E$ if there exists an arc $(i,j)$ in a directed graph
of VRPSolver such vertex pair $\{i,j\}$ projects into vertex pair $(v,v')$. In this case, we say that arc $(i,j)$
projects into edge $(v,v')$. A \bc variable is \emph{appropriate} for an edge $e\in E$ if it binary, mapped with
coefficient one only to (some or all) arcs $(i',j')$ or $(j',i')$ in directed graphs of VRPSolver which projects into
edge $e$, and not mapped to any other arc with any coefficient.

Separation of rounded capacity cuts can be used only if
\begin{enumerate}
\item packing or covering sets (depending on argument \verb+equalityCase+) are defined on vertices, i.e. no arc in any
  directed VRPSolver graph belongs to packing/covering set;
\item for each VRPSolver graph, each its arc projected to an edge (and not to a node) in graph $G$ is mapped to exactly
  one appropriate \bc variable.
\end{enumerate}

Appropriate variables are used to generate rounded capacity cuts. Note that during projection we loose information about
arc direction. Nevertheless, the generated cuts remain valid. Moreover, separation of rounded capacity cuts as core cuts
is sufficient to replace the capacity resource in VRPSolver graphs if
\begin{itemize}
\item we are in the equality case (\verb+equalityCase=true+);  
\item for every arc in VRPSolver directed graphs there exists an arc in the opposite direction;
\item all vertices in VRPSolver directed graphs except the source and the sink belong to a packing set;
\item all demands are positive and equal to all vertices belonging to the same packing set;
\item path capacity $C$ is equal for all VRPSolver directed graphs.
\end{itemize}
In this case, declaration of the capacity resource may be skipped in VRPSolver directed graphs. This may increase the
performance when the capacity resource is not tight (as for some Solomon instances of the Vehicle Routing Problem with Time
Windows). 

% The same functor may also be used to separation two-path cuts~\cite{KohlDesrosierMadsen:99u}, if argument
% \verb+twoPathCutsResId+ corresponds to . Separation of these cuts
% requires a directed graph $G'$ containing a depot node, a distance matrix between graph nodes, and time windows for
% nodes. A two-path cut is defined for a subset $S\subseteq V$ of nodes such that the whole subset of nodes cannot be
% visited by a directed path starting and finishing at the depot node which respects the path capacity, distances between
% nodes, and nodes time windows. It cuts off solutions $\bar{x}$ such that
% \begin{displaymath}
% \sum_{e=(i,j):\;|\{i,j\}\cap S|=1} \bar{x}_e< 4.
% \end{displaymath}

\bigskip

To add the functor for separation of limited-memory rank-1 cuts, on should use the constructor
\begin{lstlisting}
BcLimMemRankOneCutConstrArray(const BcFormulation & formulation,
                              const double & rootPriorityLevel = 1.0,
                              const double & nonRootPriorityLevel = 1.0);
\end{lstlisting}
Here \verb+formulation+ is the master formulation handler, and the remaining two arguments define that the root and
non-root priority level (see Section~\ref{sec:cutseparation}). Limited-memory rank-1 cuts are introduced
in~\cite{PecinPessoaPoggi:17b}. VRPSolver uses the definition of packing/covering sets in the model to separate rank-1
packing/covering cuts (see~\cite{SadykovUchoaPessoa:21l}). VRPSolver pricing functor supports limited-memory rank-1
cuts. 

\subsection{VRPSolver branching functors}
\label{sec:vrpsolverbranching}

VRPSolver extension includes two functors for separating non-robust branching constraints (these constraints are
supported in the pricing functor).

The first functor implementes separation of packing-set-based Ryan\&Foster branching constraints. To add this functor,
one should use the constructor
\begin{lstlisting}
BcPackSetRyanFosterBranching(const BcFormulation & formulation,
                             const double & priorityLevel = 1.0);
\end{lstlisting}
Here \verb+formulation+ is the master formulation handler, and \verb+priorityLevel+ is the branching priority value 
(see Section~\ref{sec:branching}). This functor searches branching candidates, each of which corresponds to a pair of
packing sets (see~\cite{PessoaSadykovUchoa:20a} for the definition of packing sets). A branching candidate generates two
branching constraints. In the first one, the number of columns corresponding to paths which include arcs (or vertices)
belonging to both packing sets is set be equal to one. In the second constraint, the number of such columns is set to be
equal to zero.

There is also a possibility to define permanent packing-set-based Ryan\&Foster constraints, using the method
of \verb+BcNetwork+:
\begin{lstlisting}
void addPermanentRyanAndFosterConstraint(int firstPackSetId, 
                                         int secondPackSetId, 
                                         bool together);
\end{lstlisting}
This method adds the following constraint to the subproblems associated with the graphs. In the case
\verb+together=false+, the path should include arcs (or vertices) belonging to at most one of packing sets
\verb+firstPackSetId+ and \verb+secondPackSetId+. In the case \verb+together=true+, the path should include arcs (or
vertices) belonging to non of these packing sets or to both of them.

\bigskip

The second functor implementes branching over accumulated resource consumption, introduced
in~\cite{PessoaSadykovUchoa:21f}. To add this functor, one should use the constructor
\begin{lstlisting}
BcPackSetResConsumptionBranching(const BcFormulation & formulation,
                                 const double & priorityLevel = 1.0);
\end{lstlisting}
Here \verb+formulation+ is the master formulation handler, and \verb+priorityLevel+ is the branching priority value (see
Section~\ref{sec:branching}).  This functor searches branching candidates, each of which corresponds to a packing set
$p$, threshold value $\tau$ for accumulated consumption of resource with index $0$. A branching candidate generates two
branching constraints. The first one forbids all columns corresponding to paths in which an arc (or vertex) belonging to
packing set $p$ is visited when the accumulated consumption of resource $0$ is less than $\tau$.  The second one forbids
all columns corresponding to paths in which an arc (or vertex) belonging to packing set $p$ is visited when the
accumulated consumption of resource $0$ is greater or equal to $\tau$.

\subsection{VRPSolver paramerization}

First of all, the following parameters should be set when using VRPSolver extension:
\begin{lstlisting}
MaxNbOfStagesInColGenProcedure = 3
colGenSubProbSolMode = 3
\end{lstlisting}

The following additional parameters are defined for the VRPSolver extension. Please
consult~\cite{PessoaSadykovUchoa:20a} for more explanation about these parameters.

\begin{lstlisting}
RCSPstopCutGenTimeThresholdInPricing = 10
RCSPhardTimeThresholdInPricing = 20
\end{lstlisting}
``Soft'' and ``hard'' time thresholds in seconds for the labeling algorithm ($\tau^{\mathrm{soft}}$ and
$\tau^{\mathrm{hard}}$ in the paper).

\begin{lstlisting}
RCSPnumberOfBucketsPerVertex = 25
RCSPdynamicBucketSteps = 1
\end{lstlisting}
Parameters for calculation of step sizes for buckets ($\psi^{\mathrm{buck}}$ and $\psi^{\mathrm{reduc}}$ in the
paper). Dynamic adjustment of bucket steps is on if \verb+RCSPdynamicBucketSteps+ takes value \verb+1+ and off if it
takes values \verb+0+.

\begin{lstlisting}
RCSPuseBidirectionalSearch = 2
\end{lstlisting}
Parameter to determine when the bi-directional labeling algorithm is used to solve the pricing problem
($\phi^{\mathrm{bidir}}$ in the paper): \verb+0+ --- not used, \verb+1+ --- always used, \verb+2+ --- used only during
the exact column generation phase.

\begin{lstlisting}
RCSPapplyReducedCostFixing = 1
\end{lstlisting}
Parameter to determine which bucket arc elimination (reduced cost fixing) procedure is used ($\phi^{\mathrm{elim}}$ in
the paper): \verb+0+ --- not used, \verb+1+ --- standard bucket arc elimination procedure
(follows~\cite{SadykovUchoaPessoa:21l}), \verb+2+ --- light bucket arc elimination procedure (less strong, but faster),
\verb+3+ --- standard arc elimination procedure (similar to~\cite{IrnichDesaulnieDesrosier:10a}), \verb+4+ --- light arc
elimination procedure.

\begin{lstlisting}
RCSPmaxNumOfColsPerExactIteration = 150
RCSPmaxNumOfColsPerIteration = 30
\end{lstlisting}
Maximum number of generated columns per column generation iteration and per subproblem with the RCSP pricing functor
($\gamma^{\mathrm{exact}}$, $\gamma^{\mathrm{heur}}$ in the paper). The first parameter is for the exact column
generation phase, and the second parameter is for heuristic column generation phases. 

\begin{lstlisting}
RCSPmaxNumOfLabelsInEnumeration = 1000000
RCSPmaxNumOfEnumeratedSolutions = 1000000
RCSPmaxNumOfEnumSolutionsForMIP = 10000
RCSPmaxNumOfEnumSolsForEndOfNodeMIP = 0
\end{lstlisting}
The first two parameters are for the maximum number of labels and paths in the elementary path enumeration procedure
($\omega^{\mathrm{labels}}$ and $\omega^{\mathrm{routes}}$ in the paper). The third parameter is for the maximum total
number of enumerated paths to trigger the solving of enumerated MIP ($\omega^{\mathrm{MIP}}$). The fourth parameter is
for the maximum total number of enumerated path to trigger the solving of enumerated MIP at the of a branch-and-bound
node. The last parameter is active only if its value is greater than the value of the third parameter. Solving enumerated MIP is not supported if the CLP solver is used instead of CPLEX.

\begin{lstlisting}
RCSPinitNGneighbourhoodSize = 8
RCSPmaxNGneighbourhoodSize = 8
\end{lstlisting}
Initial and maximum size of $ng$-sets ($\eta^{\mathrm{init}}$ and $\eta^{\mathrm{max}}$ in the paper).

\begin{lstlisting}
RCSPrankOneCutsMaxNumPerRound = 100
RCSPrankOneCutsMaxNumRows = 5
RCSPrankOneCutsMemoryType = 2
RCSPrankOneCutsLSnumIterations = 1000
\end{lstlisting}
Parameters for separation of limited-memory rank-1 cuts. First three ones correspond to parameters
$\theta^{\mathrm{num}}$, $\theta^{\mathrm{rows}}$, $\theta^{\mathrm{mem}}$ in the paper. Possible values for the third
parameters are: \verb+0+ --- automatic selection of node- or arc-memory (the root node may be solved two times in this
case), \verb+1+ --- arc-memory is used, \verb+2+ --- node-memory is used. The fourth parameters sets the number of
iterations in the local search heuristic to separate rank-1 cuts with four rows and more.

\begin{lstlisting}
RCSPallowRoutesWithSameVerticesSet = true
\end{lstlisting}
Whether multiple paths which pass by the same set of vertices (in different order) can be generated in the same
iteration of the column generation procedure. Setting this parameter to \verb+false+ may improve convergence (as more
diversified set of paths is generated in every column generation iteration) but may slow down the labelling algorithm as
the additional check is necessary.

\begin{lstlisting}
RCSPredCostFixingFalseGap = 0.0
\end{lstlisting}
If the value of this parameter is $\leq 1.0$ that it has no effect. If its value is $>1.0$ then reduced cost fixing and
enumeration are performed with the primal-dual gap is divided by this value, making the whole branch-cut-and-price
algorithm heuristic. More about the \emph{false gap mechanism} can be found in paper~\cite{QueirogaSadykovUchoa:21o}.

\begin{lstlisting}
SafeDualBoundScaleFactor = -1
\end{lstlisting}
If this parameter is positive, it activates the calculation of the safe dual bound (parameter $\tilde{K}$ in the
paper). This may be important to avoid rounding errors when the objective function is to minimize the number of paths in
the solution. Safe lower bounds for column generation were introduced in~\cite{HeldCookSewell:12a}.

The following parameters are used to activate the primal heuristic which is based on the elementary path enumeration with
false gap. This heuristic was proposed in~\cite{PessoaUchoaPoggi-de-:09a} and was also used
in~\cite{QueirogaSadykovUchoa:21o}.
\begin{lstlisting}
RCSPmaxNumOfLabelsInHeurEnumeration = 0
MaxNumEnumSolsInRestrictedMasterIpHeur = 5000
\end{lstlisting}
If the first parameter is positive, then the elementary path enumeration is triggered at the end of a some branch-and-bound
nodes (depends on parameter \verb+CallFrequencyOfRestrictedMasterIpHeur+). The primal-dual gap is divided by two each
time the enumeration does not succeed for at least one subproblem associated to the RCSP pricing functor. After
succeeding enumeration, at most \verb+MaxNumEnumSolsInRestrictedMasterIpHeur+ columns corresponding to paths with the
smallest reduced cost are added to the restricted master, and the latter is solved as a MIP. The restricted master
heuristic parameters (see Section~\ref{sec:heurconfig}) also apply here. Again, this primal heuristic cannot be used with the CLP solver.

\subsection{VRPSolver output}

To activate additional output of the VRPSolver extension, one needs to set parameter
\begin{lstlisting}
DEFAULTPRINTLEVEL = 0
\end{lstlisting}

During the initialization of each RCSP pricing functor, the following information is shown:
\scriptsize
\begin{verbatim}
RCSP solver info : symmetric case is detected for graph G_0!
Bidirectional border value is initialised to 100
RCSP solver info : number of forw. reachable buckets / 
                   buck. strongly connected components is 3856( 97.5709% ) / 1931( 50.0778% )
\end{verbatim}
\normalsize The information whether the symmetric case is detected, the initial value for the bi-directional threshold,
and the initial number of reachable buckets and the number of strongly connected components in the bucket graph
(together with the percentage from the total number of buckets). See paper~\cite{SadykovUchoaPessoa:21l} for an
additional explanation.


\medskip
After each execution of the exact bucket-graph based labeling algorithm (see paper~\cite{SadykovUchoaPessoa:21l}) to
solve the RCSP pricing problem, some statistics are shown:
\scriptsize
\begin{verbatim}
RCSP exact solver info for graph G_0 : TT = 0.092659, pt = 0.000274, dt = 0.079908, 
ct = 0.009966, ndl = 18', bdl = 466', odl = 15',  odf = 136', bsi = 1', cnt = 22', 
bdch = 3616', odch = 280', lcp = 189', #sols = 150
\end{verbatim}
\normalsize
This statistics include:
\begin{itemize}
\item the index of the subproblem to which the directed graph is associated (\verb+G_0+ means index $0$);
\item \verb+TT+: the total labelling time in seconds
\item \verb+pt+: preparation time in seconds (retrieving information about reduced costs and non-robust cuts)
\item \verb+dt+: dynamic programming time in seconds (extension of labels and dominance checks)
\item \verb+ct+: concatenation time in seconds (in the bi-directional labeling)
\item \verb+ndl+ : number of non-dominated labels in thousands
\item \verb+bdl+ : number of labels dominated by labels in the same bucket, in thousands
\item \verb+odl+ : number of labels dominated by labels in different buckets, in thousands
\item \verb+odf+ : number of times the function which checks the dominance between a label and all labels in a different
  bucket is called, in thousands
\item \verb+bsi+ : number of times a bi-directional solution is inserted to the pool of solutions of the labeling
  algorithm, in thousands
\item \verb+cnt+ : number of times a pair of forward and backward labels is tried for concatenation, in thousands
\item \verb+bdch+ : number of dominance checks between labels in the same bucket, in thousands
\item \verb+odch+ : number of dominance checks between labels in different buckets, in thousands
\item \verb+lcp+ : number of times a label is copied in the memory, in thousands
\item \verb+#sols+ : number of solutions generated by the labeling algorithm
\end{itemize}

\medskip
Every time the bucket arc elimination (reduced cost fixing) procedure is launched, the following information is
printed:
\scriptsize
\begin{verbatim}
Reduced cost fixing for graph G_0... 40752 buck. arcs remain (79.1% from prev., 3.69% from max.) 
 + 41953 jump buck. arcs (3.8% from max.)
 TT = 2.81583, pt = 0.450316, dt = 1.11438, ct = 1.24473, ndl = 307', bdl = 1252', odl = 30', 
 odf = 1139', lpcb = 1790', cnt = 20528', bdch = 40847', odch = 28678', lcp = 9921'
Labels distribution in buckets (bucket size) : largest - 507, top 0.1% - 472, top 0.5% - 376, 
 top 2% - 277, top 10% - 114, top 50% - 9
Run forward enumeration with border = 100... succeeded! lpt = 1.53273, ndl = 95', dl = 6', 
 lpcb = 912', dch = 125'
Run enumeration concatenation with time limit 30.2322 sec.... succeeded!
Sorting and storing enumerated solutions ... done!
 TT = 3.1909, pt = 0, dt = 1.53273, ct = 0.937832, ndl = 95', bdl = 6', lpcb = 912', cnt = 11817', 
 bdch = 125', odch = 0', lcp = 0'
Enumeration succeeded!, number of elem. solutions is 103246
Estimating inspection time...     TT = 0.061083, performed by inspection with 103246 solutions
Inspection time is low enough. Pricing will be done by inspection.
Removed 5445 columns (not in the enumerated set) from the formulation
Regenerated 2114 columns with the 'enumerated' flag
\end{verbatim}
\normalsize First, the number of remaining bucket arcs after the reduced cost fixing procedure is printed for each
direction together with the percentage from the number of bucket arcs before the procedure and from the maximum possible
number of bucket arcs. Then the statistics of the reduced cost fixing procedure are printed (similarly to the standard
labelling algorithm). The time to determine whether a bucket arc can be eliminated or not is included in the
concatenation time.  Then, the labels distribution statistics is shown, i.e. the number of labels in the largest bucket,
and the minimum number of labels in $0.1\%$, $0.5\%$, $2\%$, $10\%$, and $50\%$ of largest buckets. Afterwards, the
elementary path enumeration procedure is attempted, and its statistics are shown (which are again similar to to the
standard labelling statistics, except that there is no buckets). If enumeration procedure succeeds, the number of
elementary solutions is shown. Then the inspection of these solutions (to calculate their reduced cost) is tried. If the
inspection time is sufficiently low, the pricing problem passed to the ``enumerated mode''. Then VRPSolver outputs the
number of columns removed from the restricted master (because they do not correspond to any elementary solution in the
enumerated set) and the number of columns regenerated (their coefficients in master constrains may change as rank-1 cuts
has full memory in the enumerated mode).

\medskip
When the elementary path enumeration procedure does not succeed, the ratio between the final number of non-extended
labels and the total number of non-dominated labels is shown:
\footnotesize
\begin{verbatim}
Run forward enumeration with border = 100... not succeeded (ratio 0.513939) 
\end{verbatim}
\normalsize
The closer this ratio to zero, the closer is the enumeration procedure to be successful. 

\medskip
If the reduced cost fixing procedure is not called, then this information is shown:
\scriptsize
\begin{verbatim}
Full reduced cost fixing is not called (gap ratio is 0.959188)
Dynamic params and stats :  aver.obdmd = 44.8224, aver.buck.num. = 51, nbR1C = 274 
                                                                       with avMem = 11.3285
\end{verbatim}
\normalsize
This information contains the ratio of the current primal-dual gap in comparison with the primal-dual gap when the
reduced cost fixing procedure was called the last time (this ratio should be below the value of parameter\\
\verb+ReducedCostFixingThreshold+ to trigger the procedure). The information in the next line contains the average value
for the maximum depth when checking domination between labels in different buckets, the average number of buckets per
vertex, the number of active rank-1 cuts, and their average memory size. 

\medskip
When separating rank-1 cuts, the number of generated cuts for each number of rows is shown together with the statistics
for maximum and average violation:
\footnotesize
\begin{verbatim}
3 Rank-1 1-rows pack. cuts added ,  max viol. = 0.0275816, aver. viol. = 0.0243375
88 Rank-1 3-rows pack. cuts added ,  max viol. = 0.104368, aver. viol. = 0.0337835
Building structures for heuristic rank-1 packing cut separation...done!
96 Rank-1 4-rows pack. cuts added ,  max viol. = 0.0791168, aver. viol. = 0.0348517
100 Rank-1 5-rows pack. cuts added ,  max viol. = 0.100438, aver. viol. = 0.0599266
\end{verbatim}
\normalsize

\section{Perspectives}

\bc is a prototype (proof-of-concept) academic code. Bugs and numerical issues are expected. Thus, \bc is distributed
for an academic use without any warranty. The user support is not guaranteed. Although critical issues and bugs will be
addressed by request, possibly with a delay.  Corrections and extensions of this user guide will also be done by
request. No major developpement of \bc is planned in the future. On the other side, the work on the VRPSolver extension
will likely continue. We plan to extend modelling capabilities, implement additional cut separation functors, and to
improve the overall efficiency of VRPSolver.

\section*{Acknowledgements}

We appreciate financial support from Inria, Universit\'{e} de Bordeaux, Institute de Math\'{e}matiques de Bordeaux, and
CNRS (Centre Nationale de la Recherche Scientifique, France).

We would like to thank many people who contributed to the design, implementation, and maintenance of \bc and VRPSolver
extension: Issam Tahiri, Laurent Facq, Boris Detienne, Aur\'{e}lien Froger, Fran\c{c}ois Clautiaux, Pierre Pesneau, Artur
Pessoa, Eduardo Uchoa, Halil \c{S}en, Jinil Han, C\'{e}line Saubatte, Franck Labat, Romain Leguay, Teobaldo Bulh\~{o}es,
Guillaume Marquez, Eduardo Queiroga, Adeline Fonseca. The names are listed in no particular order.

\bibliographystyle{plain} 
\bibliography{refs} 


\end{document}






