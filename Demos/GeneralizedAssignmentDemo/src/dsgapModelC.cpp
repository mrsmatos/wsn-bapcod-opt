/**
 *
 * This file dsgapModelC.cpp is a part of BaPCod - a generic Branch-And-Price Code.
 * https://bapcod.math.u-bordeaux.fr
 *
 * Inria Bordeaux, All Rights Reserved. 
 * See License.pdf file for license terms.
 * 
 * This file is available only for academic use. 
 * For other uses, please contact stip-bso@inria.fr.
 *
 **/

#include "bcModelingLanguageC.hpp"
#include "bcUsefulHeadFil.hpp"
#include "dsgapModelC.hpp"

/*! 
 \file 
 
 * 
 * <b>The problem: </b><br>
 * 
 * Given a set of jobs \f$ \{1, \ldots, J\} \f$, and a set of machines \f$\{1, \ldots, M\} \f$, where every job \f$ j \f$, 
 * when assigned to a machine \f$m \f$ , uses on this machine a capacity \f$ W_{mj}\f$ and induces a cost \f$ C_{mj} \f$; 
 * the generalized assignment problem (CSP) consists in assigning jobs to machines in such a way that 
 * the total capacity used on a machine \f$ m \f$ is less or equal to the capacity of this machine \f$ W_m\f$, 
 * and the total cost induced by the jobs assignment is minimized. 
 *
  * \f{eqnarray*}{
   *    min \sum_{m=1}^{M} \sum_{j=1}^{J} C_{mj} x_{mj} & & \\
    *   \sum_{m=1}^{M} x_{mj} & \geq & 1 \qquad j = 1, ..., J \\
*       \sum_{j=1}^{J} W_{mj} x_{mj} &\leq &W_m \qquad m = 1, ..., M \\
*       x_{mj} &\in & \{0, 1\} \qquad m = 1, ..., M, \qquad j = 1, ..., J.
*   \f}
*  
* 
 * <b>The solution method:</b><br>
 * 
* In this demo, We have two models for solving this problem with Bapcod. The first model that we build using 
* the function ::buildMpModel is only a transcription of the normal IP formulation 
* (as described above). With this model, Bapcod is used only as an interface to call a MIP solver (ex Cplex).
* It does not use the column generation framework.
* 
* The second model that we build using the function ::buildColGenModel takes 
* benefit of the column generation framework.
* In order to solve the second model, Bapcod uses Dantzig-Wolfe decompostion. 
* In fact, when considering only a machine \f$ m\f$,
* there are job assignments in this machine that satisfy \f$\sum_{j=1}^{J} W_{mj} x_{mj} \leq W_m \f$;
* let \f$T_m\f$ be the number of those assignments and for \f$k=1,
* ..., T_m\f$. Let the binary variable \f$\lambda^k_m\f$ 
* be equal to \f$1\f$
* if the assignment \f$k\f$ is used for machine \f$m\f$. If one has
* enumerated all such assigmnents, each of them being known through a
* constant indicator vector \f$\delta^k_{m} = \{ \delta^k_{mj} \}_{j=1,\ldots, J} \f$
*   with  \f$\delta^k_{mj}\f$ is equal to \f$1\f$ 
* if the assignement \f$k\f$ for machine \f$m\f$ 
* includes the job \f$j\f$, then  the problem can be formulated as
* the so-called <b>master</b>: 
*
*   \f{eqnarray*}{
*      min \sum_{m=1}^{M} \sum_{j=1}^{J} C_{mj} \sum_{k=1}^{T_m} \delta^k_{mj}\lambda^k_m && \\
*      \sum_{m=1}^{M} \sum_{k=1}^{T_m}  \delta^k_{mj}\lambda^k_m  & \geq & 1 \qquad j = 1, ..., J \\
*      \sum_{k=1}^{T_m} \lambda^k_m &\le& 1 \qquad m = 1, ..., M \\
*      \lambda^k_m &\in&  \{0, 1\} \qquad m = 1, ..., M, \qquad 1 = 1, ..., T_m.
*    \f}
*
*  However there is no need to provide vectors  \f$ \delta^k_{m} \f$. Those
* can simply be generated by BaPCod as the feasible solutions of a
* so-called \"column generation <b>subproblem</b>\" defined by
* constraints:  
* 
*  \f{eqnarray*}{
*    \sum_{j=1}^{J} W_{mj} x_{mj} \leq W_m ;  x_{mj} \in  \{0, 1\} \quad j= 1,\ldots, J
*  \f}
*
*for a given machine \f$ m \f$. Hence, in the second model, variables \f$ x \f$ and
*constraints  \f$\sum_{j=1}^{J} W_{mj} x_{mj} \leq W_m \f$ are defined
*as part of subproblem \f$ m \f$. Then constraints \f$ \sum_{m=1}^{M} x_{mj}
*\geq  1 \f$ are defined as  part of the master problem in terms of
*variables \f$ x \f$ that appear as solutions to the subproblems.

*Note that the  "column generation subproblem" is a model of a well-known class: the
*knapsack problem, for which there exist specialized codes that are much more efficient than
*a generic MIP-solver as called by  BaPCod which uses the defined 
* MIP solver (ex: Cplex) for solving those subproblems.
*Hence, it is possible to provide an oracle to solve 
* the subproblems. For this, please refer 
* to the similar demo that you can find under the name: GeneralizedAssignment.
*  

*/

/*! 
 \mainpage 
 @copydoc dsgapModelC.cpp 
*/

using namespace std;

BcFormulation buildMpModel(GapData & dataStruct, BcModel & gapModel)
{

    /* Compute an initial incumbent value and use it to set artificial variable cost */
    /********************************************************************************/

    Double costUpperBound = 0;
    for (vector<Job *>::const_iterator ptr = dataStruct.jobPts().begin(); ptr != dataStruct.jobPts().end(); ++ptr)
        costUpperBound += (*ptr)->maxCostOnMachine();

    /// create an handle on model  master 
    /// *********************************
    BcFormulation mpForm(gapModel);

    BcObjective objective(mpForm);
    objective.setStatus(BcObjStatus::minInt);
    objective <= costUpperBound;

    /// Create subproblem variable class atteached to a subproblem
    /// **********************************************************
    BcVarArray xVar(mpForm, "X");
    /// set the type of Varaible of lcass xVar
    /// **************************************
    xVar.type('B');

    /// assign letter assigned to index for readibility of variable name
    /// ****************************************************************
    xVar.defineIndexNames(MultiIndexNames('m', 'j'));

    /// create a constraint classes
    /// ********************************
    BcConstrArray covConstr(mpForm, "COV");
    covConstr.defineIndexNames(MultiIndexNames('j'));

    for (int jobIndex = 0; jobIndex < dataStruct.jobPts().size(); ++jobIndex) {
        /// create a master constraint of class covConstr with index 'jobIndex' and set its rhs
        /// ********************************
        covConstr(jobIndex) >= 1;
    }

    /// create subproblem constraint class attached to a subproblem
    /// ************************************************************
    BcConstrArray knpConstr(mpForm, "KNP");
    knpConstr.defineIndexNames(MultiIndexNames('m'));

    for (int machineIndex = 0; machineIndex < dataStruct.machinePts().size(); ++machineIndex)
    {
        /// Create a constraint of class knpConstr with index 0 and set the rhs
        /// *******************************************************************
        knpConstr(machineIndex) <= dataStruct.machinePts()[machineIndex]->capacity();

        for (int jobIndex = 0; jobIndex < dataStruct.jobPts().size(); ++jobIndex)
        {
            /// Create a variable of class xVar with index 'jobIndex'
            /// ******************************************************
            xVar(machineIndex, jobIndex);

            /// add coefficient of variable of class xVar with index 'jobIndex' to constraint of class knpConstr with index m
            /// *************************************************************************************************************
            knpConstr[machineIndex] += dataStruct.jobPts()[jobIndex]->capUsageOnMachine(machineIndex)
                                       * xVar[machineIndex][jobIndex];

            /// add coefficient of variable of class xVar with index 'jobIndex' to constraint of class covConstr with index 'jobIndex'
            /// **********************************************************************************************************************
            covConstr[jobIndex] += xVar[machineIndex][jobIndex];

            /// add coefficient of variable of class xVar with index 'jobIndex' to objective
            /// ****************************************************************************
            objective += dataStruct.jobPts()[jobIndex]->costOnMachine(machineIndex) * xVar[machineIndex][jobIndex];
        }

    }

    return mpForm;
}

void buildColGenModel(GapData & dataStruct, BcModel & gapModel)
{

  /* Compute an initial incumbent value and use it to set artificial variable cost */
  /********************************************************************************/

  Double costUpperBound = 0;
  for (vector<Job *>::const_iterator ptr = dataStruct.jobPts().begin(); ptr != dataStruct.jobPts().end(); ++ptr)
    costUpperBound += (*ptr)->maxCostOnMachine();

  BcObjective objective(gapModel);
  objective.setStatus(BcObjStatus::minInt);

  objective <= costUpperBound;
  objective.setArtCostValue(costUpperBound / 2);

  /// create an handle on model  master 
  /// *********************************
  BcMaster master(gapModel);

  /// create a master constraint class
  /// ********************************
  BcConstrArray covConstr(master, "COV");

  for (int jobIndex = 0; jobIndex < dataStruct.jobPts().size(); ++jobIndex)
    {
      /// create a master constraint of class covConstr with index 'jobIndex' and set its rhs
      /// ********************************
      covConstr(jobIndex) >= 1;
    }

  /// Define new class of column generation subproblem
  /// ************************************************
  BcColGenSpArray colGenSp(gapModel);

  for (int machineIndex = 0; machineIndex < dataStruct.machinePts().size(); ++machineIndex)
    {

      /// Define bound on the number of subproblem solution used in master
      /// ******************************
      colGenSp[machineIndex] <= 1;
      colGenSp[machineIndex] >= 0;

      /// Create subproblem variable class atteached to a subproblem
      /// **********************************************************
      BcVarArray xVar(colGenSp[machineIndex], "X");
      /// set the type of Varaible of lcass xVar
      /// **************************************
      xVar.type('B');

      /// assign letter assigned to index for readibility of variable name
      /// ****************************************************************
      xVar.defineIndexNames(MultiIndexNames('j'));

      /// create subproblem constraint class attached to a subproblem
      /// ************************************************************
      BcConstrArray knpConstr(colGenSp[machineIndex], "KNP");

      /// Create a constraint of class knpConstr with index 0 and set the rhs
      /// *******************************************************************
      knpConstr(0) <= dataStruct.machinePts()[machineIndex]->capacity();

      for (int jobIndex = 0; jobIndex < dataStruct.jobPts().size(); ++jobIndex)
        {
          /// Create a variable of class xVar with index 'jobIndex'
          /// ******************************************************
          xVar(jobIndex);

          /// add coefficient of variable of class xVar with index 'jobIndex' to constraint of class knpConstr with index 0
          knpConstr[0] += dataStruct.jobPts()[jobIndex]->capUsageOnMachine(machineIndex) * xVar[jobIndex];

          /// add coefficient of variable of class xVar with index 'jobIndex' to constraint of class covConstr with index 'jobIndex'
          covConstr[jobIndex] += xVar[jobIndex];

	      /// set the default dual value of convConstraint
	      covConstr[jobIndex].dualVal(- dataStruct.jobPts()[jobIndex]->maxCostOnMachine());

          /// add coefficient of variable of class xVar with index 'jobIndex' to objective
          objective += dataStruct.jobPts()[jobIndex]->costOnMachine(machineIndex) * xVar[jobIndex];
        }

    }

  return;
}
